// =======================
// GLOBAL CONFIGURATION
// =======================
const w = window.innerWidth;
const h = window.innerHeight;

// Shelter ground Y (adjust as needed to match your ground line)

// =======================
// GAME STATE
// =======================
const gameState = {
  // Level system
  level: 1,
  baseBuildCosts: { fire: 3, bucket: 5, shelter: 7 },
  buildCosts: { fire: 3, bucket: 5, shelter: 7 },

  // Scene reference
  scene: null,

  // Player state
  player: null,
  health: 100,
  maxHealth: 100,
  playerTemp: 70,

  // Survival needs
  hunger: 15,
  maxHunger: 100,
  thirst: 15,
  // Start at 7:00 AM (minutes)
  gameTime: 7 * 60,
  // Alias for clarity: day start in minutes (7:00 AM)
  dayStart: 7 * 60,

  // Inventory
  sticksCollected: 0,
  waterCollected: 0,

  // Tree climbing
  treeTrunk: null,
  branches: null,
  maxBranches: 3,
  branchRegenerationDelay: 10, // seconds
  lastBranchGrowTime: 0, // Track when last branch grew
  branchGrowCooldown: 10, // seconds between branch growths

  // Saw sound state
  spacePressed: false,
  sawSoundPlaying: false,
  spaceDownTime: 0,

  // Fire building
  buildingFire: false,

  // Build system
  buildMode: null, // 'fire' or 'bucket' when placing
  placementItem: null, // The sprite being placed
  placementArrowLeft: null,
  placementArrowRight: null,

  // Shelters
  shelters: [],
  // Active fires (array of fire sprites)
  fires: [],
  // Buckets placed in the world (for rain collection)
  buckets: [],
  // Shelter platforms (for physics)
  shelterPlatforms: null,
  snapped: false,
  // Game over flag
  isGameOver: false,
};

function preload() {
  this.load.spritesheet('spritesheet', 'assets/Sprite_Sheet.png', {
    frameWidth: 64,
    frameHeight: 64
  });
  this.load.image('fire_player', 'assets/fire_player.png');

  // Fire sprites
  this.load.spritesheet('fire_spritesheet', 'assets/fire_sprite_sheet.png', {
    frameWidth: 64,
    frameHeight: 64
  });

  // Bucket sprites
  this.load.spritesheet('bucket_spritesheet', 'assets/bucket_sprite_sheet.png', {
    frameWidth: 64,
    frameHeight: 64
  });

  // Ground sprites
  this.load.spritesheet('grass_spritesheet', 'assets/grass_sprite_sheet.png', {
    frameWidth: 256,
    frameHeight: 64
  });

  // Tool sprites
  this.load.spritesheet('saw_sprite_sheet', 'assets/saw_sprite_sheet.png', {
    frameWidth: 64,
    frameHeight: 64
  });

  // Shelter sprite
  this.load.spritesheet('shelter', 'assets/shelter_sprite.png', {
    frameWidth: 128,
    frameHeight: 128
  });

  // Critical game assets
  this.load.image('tree', 'assets/tree_sprite.png');
  this.load.image('branch', 'assets/branch_sprite.png');
  this.load.image('berry', 'assets/berry.png');
  this.load.image('berry_bush', 'assets/berry_bush_sprite.png');
  this.load.image('raindrop', 'assets/raindrop.png');

  // Placeholder images (unused in current build)
  this.load.image('platform', 'https://content.codecademy.com/courses/learn-phaser/physics/platform.png');
  this.load.image('bug2', 'https://content.codecademy.com/courses/learn-phaser/physics/bug_2.png');
  this.load.image('bug3', 'https://content.codecademy.com/courses/learn-phaser/physics/bug_3.png');
  this.load.image('codey', 'https://content.codecademy.com/courses/learn-phaser/physics/codey.png');

  // Audio
  this.load.audio('sawAttack', 'assets/Attack_Note.mp3');
  this.load.audio('sawSustain', 'assets/Sustain_Note.mp3');
  this.load.audio('sawRelease', 'assets/Release_Note.mp3');
  this.load.audio('sawFullNote', 'assets/Survival_Note.mp3');
  this.load.audio('backgroundMusic', 'assets/Survival_Music.mp3');

  // Sound effects
  this.load.audio('chainsaw', 'assets/audio/chainsaw.mp3');
  this.load.audio('climbing', 'assets/audio/climbing.mp3');
  this.load.audio('gulp', 'assets/audio/gulp.mp3');
  this.load.audio('jump', 'assets/audio/jump.mp3');
  this.load.audio('menuSelection', 'assets/audio/menu_selection.mp3');
  this.load.audio('placement', 'assets/audio/placement.mp3');
  this.load.audio('waterDrop', 'assets/audio/water_drop.mp3');
  this.load.audio('startFire', 'assets/audio/start_fire.mp3');
  this.load.audio('fire', 'assets/audio/fire.mp3');
  this.load.audio('fire_out', 'assets/audio/fire_out.mp3');
  this.load.audio('crouch', 'assets/audio/crouch.mp3');
  this.load.audio('pickUpItem', 'assets/audio/pick_up_item.mp3');
  // New audio
  this.load.audio('footsteps', 'assets/audio/footsteps.mp3');
  this.load.audio('rain', 'assets/audio/rain.mp3');
}

// Helper: safely set a sprite's texture/frame with graceful fallback.
function safeSetTexture(sprite, key, frame) {
  if (!sprite || !sprite.scene) return;
  try {
    if (typeof frame !== 'undefined') {
      const texture = sprite.scene.textures.get(key);
      if (texture && texture.has(frame)) {
        sprite.setTexture(key, frame);
      } else {
        sprite.setTexture(key, 0);
      }
    } else {
      sprite.setTexture(key);
    }
  } catch (e) {
    // Silently fail
  }
} 
function safeSetFrame(sprite, frame) {
  if (!sprite) return;
  try {
    const texture = sprite.texture;
    if (texture && texture.has(frame)) {
      sprite.setFrame(frame);
    } else if (texture && texture.has(0)) {
      sprite.setFrame(0);
    }
  } catch (e) {
    // Silently fail
  }
}

// =======================
// CREATE SCENE
// =======================
function create() {
                            // Prevent spawning if more than 25% of this bush would overlap with another bush
                            if (gameState.berryBushes) {
                              for (const otherBush of gameState.berryBushes.getChildren()) {
                                // Skip self (shouldn't happen on spawn, but safe)
                                if (!otherBush.active) continue;
                                const bushRect = new Phaser.Geom.Rectangle(x-32, y-32, 64, 64);
                                const otherRect = new Phaser.Geom.Rectangle(otherBush.x-32, otherBush.y-32, 64, 64);
                                if (Phaser.Geom.Intersects.RectangleToRectangle(bushRect, otherRect)) {
                                  // Calculate intersection area
                                  const ix = Math.max(bushRect.x, otherRect.x);
                                  const iy = Math.max(bushRect.y, otherRect.y);
                                  const iw = Math.min(bushRect.right, otherRect.right) - ix;
                                  const ih = Math.min(bushRect.bottom, otherRect.bottom) - iy;
                                  if (iw > 0 && ih > 0) {
                                    const intersectionArea = iw * ih;
                                    const bushArea = 64 * 64;
                                    if (intersectionArea / bushArea > 0.25) return false;
                                  }
                                }
                              }
                            }
              // Bush sound
              gameState.bushSound = this.sound.add('bush');
            // -----------------
            // BERRY BUSHES
            // -----------------
            // Group for berry bushes
            gameState.berryBushes = this.physics.add.staticGroup();
            // Group for berries
            gameState.berries = this.physics.add.group();

            // Helper to check overlap with shelters, fires, buckets, and trunk
            function isValidBerryBushPosition(x, y) {
              // Expose for regrowth logic in update()
              this.isValidBerryBushPosition = isValidBerryBushPosition;
              // Check overlap with shelters
              for (const shelter of gameState.shelters) {
                if (Phaser.Geom.Intersects.RectangleToRectangle(
                  new Phaser.Geom.Rectangle(x-32, y-32, 64, 64),
                  shelter.getBounds()
                )) return false;
              }
              // Check overlap with fires
              for (const fire of gameState.fires) {
                if (Phaser.Geom.Intersects.RectangleToRectangle(
                  new Phaser.Geom.Rectangle(x-32, y-32, 64, 64),
                  fire.getBounds()
                )) return false;
              }
              // Check overlap with buckets
              for (const bucket of gameState.buckets) {
                if (Phaser.Geom.Intersects.RectangleToRectangle(
                  new Phaser.Geom.Rectangle(x-32, y-32, 64, 64),
                  bucket.getBounds()
                )) return false;
              }
              // Prevent spawning under the tree trunk (bush width must be fully outside trunk width)
              if (gameState.treeTrunk) {
                const trunkLeft = gameState.treeTrunk.x - gameState.treeTrunk.width / 2;
                const trunkRight = gameState.treeTrunk.x + gameState.treeTrunk.width / 2;
                const bushLeft = x - 32;
                const bushRight = x + 32;
                // Bush must be fully to the left or right of trunk
                if (!(bushRight < trunkLeft || bushLeft > trunkRight)) return false;
              }
              return true;
            }

            // Helper to spawn a berry bush at a valid random position
            function spawnBerryBush() {
              let tries = 0;
              let x, y;
              do {
                x = Phaser.Math.Between(100, w - 100);
                y = h - 96; // Place on ground, adjust as needed
                tries++;
              } while (!isValidBerryBushPosition.call(gameState.scene, x, y) && tries < 20);
              if (tries >= 20) return null;
              const bush = gameState.berryBushes.create(x, y, 'berry_bush', 0).setDepth(220).setScale(1);
              bush.setData('berries', 10);
              bush.setData('regrowing', false);
              bush.setData('frameTimer', 0);
              bush.setData('frame', 0);
              bush.setInteractive();
              return bush;
            }

            // Only spawn bushes after trunk is created
            this.time.delayedCall(0, () => {
              for (let i = 0; i < 2; i++) {
                spawnBerryBush();
              }
            });
          // Weather pattern: storms only 10% of the time
          // Schedule first storm
          const dayMinutes = 24 * 60;
          const stormDurationMin = 120; // min storm duration in minutes (2 hours)
          const stormDurationMax = 60; // max storm duration in minutes
          const maxRainPerDay = 144; // 2.4 hours (10% of 24h)
          // Precompute all storms for the day
          const scheduleStormsForDay = (dayStart) => {
            let totalRain = 0;
            let storms = [];
            let time = dayStart + Phaser.Math.Between(10, 60); // Don't start at midnight
            while (totalRain < maxRainPerDay) {
              let maxStorm = Math.min(stormDurationMax, maxRainPerDay - totalRain);
              let stormLength = Phaser.Math.Between(stormDurationMin, maxStorm);
              if (totalRain + stormLength > maxRainPerDay) stormLength = maxRainPerDay - totalRain;
              storms.push({ start: time, end: time + stormLength });
              totalRain += stormLength;
              time += stormLength + Phaser.Math.Between(30, 120); // Gaps between storms
              if (time > dayStart + 24 * 60) break;
            }
            return storms;
          };
          gameState.scheduleStormsForDay = scheduleStormsForDay;
        // Footsteps and rain audio
        gameState.footstepsSound = this.sound.add('footsteps', { loop: true, volume: 2 });
        gameState.rainSound = this.sound.add('rain', { loop: true, volume: 0.2 });
      // Force integer pixel rendering for pixel art
      this.cameras.main.roundPixels = true;
    // Track current shelter preview frame
    gameState.shelterPreviewFrame = 0;
    // Get number of frames in shelter spritesheet (assume 4 if not known)
    gameState.shelterFrameCount = this.textures.get('shelter').frameTotal || 4;
  const centerX = this.cameras.main.width / 2;
  const centerY = this.cameras.main.height / 2;

  gameState.scene = this;
  // Ensure game over flag is cleared when scene starts/restarts
  gameState.isGameOver = false;
  // Reset score on scene start
  gameState.score = 0;

  // Score timer: add 1 point for each real second the player is alive
  if (!gameState.scoreTimer) {
    gameState.scoreTimer = this.time.addEvent({
      delay: 1000,
      loop: true,
      callback: () => {
        if (!gameState.isGameOver) {
          gameState.score = (gameState.score || 0) + 1;
          if (gameState.scoreText) gameState.scoreText.setText(`Score: ${gameState.score}`);
        }
      }
    });
  }

  // -----------------
  // AUDIO SETUP
  // -----------------
  gameState.backgroundMusic = this.sound.add('backgroundMusic', {
    loop: true,
    volume: 0.5
  });
  gameState.backgroundMusic.play();

  // Saw sound objects (old system - keeping for compatibility)
  gameState.sawAttack = this.sound.add('chainsaw', { volume: 0.6 }); // Use chainsaw.mp3
  gameState.sawSustain = this.sound.add('sawSustain');
  gameState.sawSustainLoop = this.sound.add('sawSustain', { loop: true });
  gameState.sawRelease = this.sound.add('sawRelease');
  gameState.sawFullNote = this.sound.add('sawFullNote');

  // New sound effects
  gameState.climbingSound = this.sound.add('climbing', { loop: true, volume: 0.5 });
  gameState.gulpSound = this.sound.add('gulp', { volume: 0.7 });
  gameState.jumpSound = this.sound.add('jump', { volume: 0.6 });
  gameState.menuSelectionSound = this.sound.add('menuSelection', { volume: 0.5 });
  gameState.waterDropSound = this.sound.add('waterDrop', { volume: 0.6 });
  gameState.placementSound = this.sound.add('placement', { volume: 0.7 });
  gameState.startFireSound = this.sound.add('startFire', { volume: 0.7 });
  gameState.fireSound = this.sound.add('fire', { loop: true, volume: 0.5 });
  gameState.fireOutSound = this.sound.add('fire_out', { volume: 0.7 });
  gameState.crouchSound = this.sound.add('crouch', { volume: 0.6 });
  gameState.pickUpItemSound = this.sound.add('pickUpItem', { volume: 1.5 });

  // Fire sound chain - play looping fire sound after start fire completes
  gameState.startFireSound.on('complete', () => {
    // Only start fire loop if there's at least one active fire
    if (gameState.fires && gameState.fires.length > 0) {
      gameState.fireSound.play();
    }
  });

  // Saw sound event listeners
  gameState.sawAttack.on('complete', () => {
    if (gameState.cursors.space.isDown && gameState.isClimbing) {
      gameState.sawSustainLoop.play();
    }
  });

  gameState.sawSustain.on('complete', () => {
    gameState.sawRelease.play();
  });

  // -----------------
  // BACKGROUND & ENVIRONMENT
  // -----------------
  // Horizon gradient (rendered behind tree)
  gameState.horizon = this.add.graphics();
  gameState.horizon.setDepth(-1);

  // Sun and Moon
  gameState.sun = this.add.circle(0, 0, 30, 0xFFFF00).setDepth(-0.5).setOrigin(0.5);
  gameState.moon = this.add.circle(0, 0, 25, 0xEEEEEE).setDepth(-0.5).setOrigin(0.5);
  
  gameState.moon.setVisible(false);

  // -----------------
  // TREE & BRANCHES
  // -----------------
  // Main tree sprite
  const treeImage = this.add.image(
    centerX,
    this.cameras.main.height - (128 * 2) - 47, // Move up by 7px total
    'tree'
  ).setScale(4).setDepth(210);

  // Invisible climbable trunk zone
  gameState.treeTrunk = this.add.zone(
    centerX + 5,
    this.cameras.main.height - (128 * 2) + 10, // Move up by 7px total
    70,
    300
  );
  this.physics.world.enable(gameState.treeTrunk);
  gameState.treeTrunk.body.setAllowGravity(false);
  gameState.treeTrunk.body.moves = false;

  // Visual shade under the tree (oblong ellipse) to indicate safe zone
  // Position it around the base of the trunk; depth is below player but above ground
  const shadeX = gameState.treeTrunk.x+5;
  const shadeY = gameState.treeTrunk.y + gameState.treeTrunk.height / 2 + 30;
  const shadeW = 420; // width of ellipse
  const shadeH = 80;  // height of ellipse (oblong)
  gameState.treeShade = this.add.graphics();
  gameState.treeShade.fillStyle(0x000000, 0.35);
  gameState.treeShade.fillEllipse(shadeX, shadeY, shadeW, shadeH);
  gameState.treeShade.setDepth(205);

  // Create branches on tree
  gameState.branches = this.physics.add.group();
  const branchCount = 3;
  gameState.maxBranches = branchCount;
  const minSpacing = 50;
  const branchMargin = 20; // Keep branches below trunk top
  const availableHeight = gameState.treeTrunk.height * (2 / 3);
  const spacing = Math.max(minSpacing, availableHeight / (branchCount + 1));
  const startY = gameState.treeTrunk.y - (gameState.treeTrunk.height / 2) + branchMargin;

  for (let i = 0; i < branchCount; i++) {
    const yPosition = startY + spacing * (i + 1) - 7; // Move each branch up by 7px total
    const newBranch = gameState.branches.create(
      gameState.treeTrunk.x,
      yPosition,
      'branch',
      0 // Start with frame 0 (full branch)
    ).setScale(1.5).setDepth(300);

    newBranch.body.setAllowGravity(false);
    newBranch.body.setImmovable(true);

    // Set branch health (3 = full health)
    newBranch.setData('health', 3);

    // Randomly place branch on left or right side
    if (Math.random() > 0.5) {
      newBranch.setFlipX(true);
      newBranch.x += gameState.treeTrunk.width;
    } else {
      newBranch.x -= gameState.treeTrunk.width;
    }

    // Mark as attached to tree
    newBranch.setData('onTree', true);
    // Remember original Y so we can reliably reattach this branch after it falls
    newBranch.setData('origY', yPosition);
  }

  // -----------------
  // GROUND & GRASS
  // -----------------
  // Grass sprites
  
  const grasses = this.physics.add.staticGroup();
  const grassPositions = [0, 1, 2, 3, 4, 5, 6, 7];

  

  grassPositions.forEach(t => {
    const grassBottom = grasses.create(
      Math.round(256 * t),
      Math.round(this.cameras.main.height - (36 * 2) - 62),
      'grass_spritesheet'
    ).setScale(1).setDepth(0).setFlipX(true).refreshBody();
    // Crop 1px from the bottom to hide edge artifact
    grassBottom.setCrop(0, 0, 256, 61);
  });

  // Ground platform (visual)
  const platformGraphics = this.add.graphics();
  platformGraphics.fillStyle(0x6B4423, 1);
  platformGraphics.fillRect(0, this.cameras.main.height - 60, this.cameras.main.width, 60);
  platformGraphics.setDepth(100);
  platformGraphics.setVisible(false); // Hide platform graphics for debugging

  // Ground platform (physics, invisible)
  gameState.platforms = this.physics.add.staticGroup();
  const platform = gameState.platforms.create(
    centerX,
    this.cameras.main.height - 40,
    'platform'
  ).setDepth(100);
  const scaleX = this.cameras.main.width / platform.width;
  platform.setScale(scaleX, 0.6).refreshBody();
  platform.setAlpha(0);

  // Shelter platforms (for physics, true collision)
  gameState.shelterPlatforms = this.physics.add.staticGroup();

  // -----------------
  // PLAYER SETUP
  // -----------------
  gameState.player = this.physics.add.sprite(
    centerX * 0.75,
    this.cameras.main.height - 94,
    'spritesheet',
    0
  ).setScale(1).setDepth(300);

  // Adjust physics body to match sprite
  gameState.player.body.setSize(44, 52);
  gameState.player.body.setOffset(9, 8);
  gameState.player.setCollideWorldBounds(true);

  // Player uses world gravity (we disable it only during climbing)
  gameState.player.body.setAllowGravity(true);

  // -----------------
  // ANIMATIONS
  // -----------------
  this.anims.create({
    key: 'grassMove',
    frames: this.anims.generateFrameNumbers('grass_spritesheet', {
      start: 0,
      end: 1
    }),
    frameRate: 2,
    repeat: -1
  });
  this.anims.play('grassMove', grasses.getChildren());

  this.anims.create({
    key: 'sawSpin',
    frames: this.anims.generateFrameNumbers('saw_sprite_sheet', {
      start: 0,
      end: 2
    }),
    frameRate: 6,
    repeat: -1
  });

  this.anims.create({
    key: 'fireBurn',
    frames: this.anims.generateFrameNumbers('fire_spritesheet', {
      start: 0,
      end: 3
    }),
    frameRate: 8,
    repeat: -1
  });

  this.anims.create({
    key: 'fireIconAnim',
    frames: this.anims.generateFrameNumbers('fire_spritesheet', {
      start: 0,
      end: 3
    }),
    frameRate: 8,
    repeat: -1
  });

  // -----------------
  // UI ELEMENTS
  // -----------------
  // Level title (top center)
  gameState.levelText = this.add.text(centerX, 20, 'Level 1', {
    fontSize: '24px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0);

  // Resource counters (left side, vertically centered)
  const inventoryX = 20; // Left margin
  const inventoryStartY = h * 0.5 - 30; // Vertically centered

  // UI vertical stack positions
  let uiStackY = inventoryStartY - 200;
  // Branch icon and count
  gameState.stickIcon = this.add.image(inventoryX + 12, uiStackY, 'branch')
    .setScale(1).setOrigin(0.5, 0);
  gameState.stickText = this.add.text(inventoryX + 12, uiStackY + 36, `${gameState.sticksCollected}`, {
    fontSize: '20px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0);

  // Water drop (thirst) icon and value
  uiStackY += 70;
  gameState.waterIcon = this.add.image(inventoryX + 12, uiStackY, 'raindrop')
    .setScale(0.6).setOrigin(0.5, 0);
  gameState.waterText = this.add.text(inventoryX + 12, uiStackY + 40, `${gameState.thirst}`, {
    fontSize: '20px',
    fill: '#00aa00',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 2
  }).setOrigin(0.5, 0);

  // Berry (hunger) icon and value, below water drop
  uiStackY += 70;
  gameState.berryIcon = this.add.image(inventoryX + 12, uiStackY, 'berry')
    .setScale(0.6).setOrigin(0.5, 0);
  gameState.berryText = this.add.text(inventoryX + 12, uiStackY + 40, `${gameState.hunger}`, {
    fontSize: '20px',
    fill: '#00aa00',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 2
  }).setOrigin(0.5, 0);

  // Health bar (below level text at top center)
  const healthBarX = centerX - 75; // Center the 150px wide bar
  const healthBarY = 50; // Just below level text
  const healthBarWidth = 150;
  const healthBarHeight = 20;

  gameState.healthBarBg = this.add.graphics();
  gameState.healthBarBg.fillStyle(0x8B0000, 1);
  gameState.healthBarBg.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

  gameState.healthBar = this.add.graphics();
  gameState.healthBar.fillStyle(0x90ee90, 1);
  gameState.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

  gameState.healthBarBorder = this.add.graphics();
  gameState.healthBarBorder.lineStyle(2, 0x000000, 1);
  gameState.healthBarBorder.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

  gameState.healthText = this.add.text(
    healthBarX + healthBarWidth / 2,
    healthBarY + healthBarHeight / 2+1,
    '100/100',
    { fontSize: '14px', fill: '#000000', fontStyle: 'bold' }
  ).setOrigin(0.5);

  // Player temperature status (below health bar at top center)
  const tempStatusX = this.cameras.main.width - 130;
  const tempStatusY = 76; // Below health bar

  gameState.playerTempBg = this.add.graphics();
  gameState.playerTempBg.fillStyle(0x000000, 0.7);
  const tempBoxX = tempStatusX - 2;
  const tempBoxY = tempStatusY - 2;
  const tempBoxW = 120;
  const tempBoxH = 22;
  gameState.playerTempBg.fillRect(tempBoxX, tempBoxY, tempBoxW, tempBoxH);
  // Center the temperature text inside the background box
  gameState.playerTempText = this.add.text(tempBoxX + tempBoxW / 2, tempBoxY + tempBoxH / 2, 'Comfortable', {
    fontSize: '16px',
    fill: '#00aa00',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0.5);

  // Temperature status message (below player temp status)
  gameState.tempStatusMessage = this.add.text(centerX, tempStatusY + 25, '', {
    fontSize: '18px',
    fill: '#ffffff',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 3
  }).setOrigin(0.5, 0).setVisible(false);

  // Time and temperature displays (top right)
  gameState.timeText = this.add.text(w * 0.975, h * 0.025, '6:00 AM', {
    fontSize: '20px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(1, 0);

  gameState.tempText = this.add.text(w * 0.975, h * 0.025 + 28, '65Â°F', {
    fontSize: '18px',
    fill: '#000000'
  }).setOrigin(1, 0);

  // Sky debug overlay (shows time, sun/moon positions and visibility)
  gameState.skyDebugText = this.add.text(w * 0.7, h * 0.025, '', {
    fontSize: '12px',
    fill: '#ffffff',
    backgroundColor: 'rgba(0,0,0,0.4)',
    padding: { x: 6, y: 4 }
  }).setOrigin(0, 0).setDepth(10000);

  // Music controls (centered vertically on right wall)
  const musicControlsX = w * 0.98;
  const musicControlsY = this.cameras.main.height / 2;

  // Play/Pause button
  gameState.musicPlayPauseButton = this.add.text(musicControlsX, musicControlsY - 30, 'â¸', {
    fontSize: '28px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(1, 0.5).setInteractive().setDepth(200);

  gameState.musicPlayPauseButton.on('pointerdown', () => {
    if (gameState.backgroundMusic.isPlaying) {
      gameState.backgroundMusic.pause();
      gameState.musicPlayPauseButton.setText('â–¶');
    } else {
      gameState.backgroundMusic.resume();
      gameState.musicPlayPauseButton.setText('â¸');
    }
  });

  // Volume button
  gameState.volumeButton = this.add.text(musicControlsX*1.003, musicControlsY + 32, 'ðŸ”Š', {
    fontSize: '28px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(1, 0.5).setInteractive().setDepth(200);

  // Volume levels: 0.5 (default), 0.25, 0, 0.75, 1.0
  gameState.volumeLevels = [0.5, 0.25, 0, 0.75, 1.0];
  gameState.currentVolumeIndex = 0;

  gameState.volumeButton.on('pointerdown', () => {
    gameState.currentVolumeIndex = (gameState.currentVolumeIndex + 1) % gameState.volumeLevels.length;
    const newVolume = gameState.volumeLevels[gameState.currentVolumeIndex];
    gameState.backgroundMusic.setVolume(newVolume);

    // Update button icon based on volume
    if (newVolume === 0) {
      gameState.volumeButton.setText('ðŸ”‡');
    } else if (newVolume <= 0.25) {
      gameState.volumeButton.setText('ðŸ”‰');
    } else {
      gameState.volumeButton.setText('ðŸ”Š');
    }
  });

  // Build UI (top left corner)
  const buildUIX = 20; // Left margin
  const buildUIY = 20; // Top margin

  gameState.buildLabel = this.add.text(buildUIX, buildUIY, 'Build Menu (b)', {
    fontSize: '18px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(0, 0).setDepth(200);

  // Fire icon (clickable, costs 3 branches)
  gameState.buildFireIcon = this.add.sprite(buildUIX + 10, buildUIY + 40, 'fire_spritesheet', 0)
    .setScale(0.4).setOrigin(0.5, 0.5).setInteractive().setDepth(200);
  gameState.buildFireIcon.anims.play('fireIconAnim', true);

  // Fire icon hover effects
  gameState.buildFireIcon.on('pointerover', () => {
    gameState.buildFireIcon.setScale(0.6); // 1.5x the original 0.4 scale
  });
  gameState.buildFireIcon.on('pointerout', () => {
    gameState.buildFireIcon.setScale(0.4); // Back to original scale
  });

  // Bucket icon (clickable, costs 5 branches)
  gameState.buildBucketIcon = this.add.sprite(buildUIX + 50, buildUIY + 42, 'bucket_spritesheet', 0)
    .setScale(0.4).setOrigin(0.5, 0.5).setInteractive().setDepth(200);

  // Bucket icon hover effects
  gameState.buildBucketIcon.on('pointerover', () => {
    gameState.buildBucketIcon.setScale(0.6); // 1.5x the original 0.4 scale
  });
  gameState.buildBucketIcon.on('pointerout', () => {
    gameState.buildBucketIcon.setScale(0.4); // Back to original scale
  });

  // Shelter icon (clickable, costs 7 branches)
  gameState.buildShelterIcon = this.add.sprite(buildUIX + 90, buildUIY + 42, 'shelter', 0)
    .setScale(0.2).setOrigin(0.5, 0.5).setInteractive().setDepth(200);

  // Shelter icon hover effects
  gameState.buildShelterIcon.on('pointerover', () => {
    gameState.buildShelterIcon.setScale(0.3); // 1.5x the original 0.2 scale
  });
  gameState.buildShelterIcon.on('pointerout', () => {
    gameState.buildShelterIcon.setScale(0.2); // Back to original scale
  });

  // Build cost text (shown below build menu when item selected)
  gameState.buildCostText = this.add.text(buildUIX + 45, buildUIY + 75, '', {
    fontSize: '16px',
    fill: '#000000',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0).setDepth(200).setVisible(false);

  // Info text at bottom center (in platform, same level as check/x buttons)
  const placementUIY = this.cameras.main.height - 45;

  gameState.infoText = this.add.text(centerX, placementUIY + 20, '', {
    fontSize: '20px',
    fill: '#ffffff',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 3
  }).setOrigin(0.5, 0.5).setDepth(300).setVisible(false);

  // Colored check and x for build menu (positioned below infoText)
  gameState.infoTextCheck = this.add.text(centerX - 160, placementUIY + 20, 'âœ“ (Enter) ', {
    fontSize: '20px',
    fill: '#00ff00',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 3
  }).setOrigin(0.5, 0.5).setDepth(300).setVisible(false);

  gameState.infoTextX = this.add.text(centerX + 180, placementUIY + 20, 'âœ— (Backspace)', {
    fontSize: '20px',
    fill: '#ff0000',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 3
  }).setOrigin(0.5, 0.5).setDepth(300).setVisible(false);

  // Placement confirmation buttons (hidden by default, shown during placement)

  gameState.checkButton = this.add.text(centerX, placementUIY, 'âœ“', {
    fontSize: '30px',
    fill: '#00ff00',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0.5).setInteractive().setDepth(1000).setVisible(false);

  gameState.xButton = this.add.text(centerX + 40, placementUIY, 'âœ—', {
    fontSize: '30px',
    fill: '#ff0000',
    fontStyle: 'bold'
  }).setOrigin(0.5, 0.5).setInteractive().setDepth(1000).setVisible(false);

  // Register button event listeners ONCE here (not in icon handlers)
  gameState.checkButton.on('pointerdown', () => {
    if (gameState.buildMode === 'fire' && gameState.sticksCollected >= 3) {
      // Deduct branches
      gameState.sticksCollected -= gameState.buildCosts.fire;
      gameState.stickText.setText(`${gameState.sticksCollected}`);

      // Create actual fire at placement position
      const fire = this.add.sprite(
        gameState.placementItem.x,
        gameState.placementItem.y,
        'fire_spritesheet'
      ).setScale(1).setDepth(210);

      this.physics.world.enable(fire);
      fire.body.setAllowGravity(false);
      fire.body.setImmovable(true);
      fire.body.setSize(40, 40);
      fire.anims.play('fireBurn', true);
      gameState.fires.push(fire);

      // Play start fire sound (will chain to looping fire sound on complete)
      gameState.startFireSound.play();

      // Show build notification      // Clean up placement UI
      gameState.placementItem.destroy();
      gameState.placementArrowLeft.destroy();
      gameState.placementArrowRight.destroy();
      gameState.buildMode = null;
      gameState.checkButton.setVisible(false);
      gameState.xButton.setVisible(false);
    } else if (gameState.buildMode === 'bucket' && gameState.sticksCollected >= 5) {
      // Deduct branches
      gameState.sticksCollected -= gameState.buildCosts.bucket;
      gameState.stickText.setText(`${gameState.sticksCollected}`);

      // Create actual bucket at placement position
      const bucket = this.add.sprite(
        gameState.placementItem.x,
        gameState.placementItem.y,
        'bucket_spritesheet',
        0
      ).setScale(1).setDepth(210);

      this.physics.world.enable(bucket);
      bucket.body.setAllowGravity(false);
      bucket.body.setImmovable(true);
      bucket.body.setSize(40, 40);

      // Add fill percentage data and text display
      bucket.setData('fillPercent', 0);
      const fillText = this.add.text(
        bucket.x,
        bucket.y - 40,
        '0%',
        { fontSize: '16px', fill: '#ffffff', fontStyle: 'bold', stroke: '#000000', strokeThickness: 3 }
      ).setOrigin(0.5).setDepth(210);
      bucket.setData('fillText', fillText);

      // Store bucket for rain collection
      gameState.buckets.push(bucket);

      gameState.placementSound.play(); // Play placement sound

      // Show build notification
      showInfoText('You built a Bucket', 2000);

      // Clean up placement UI
      gameState.placementItem.destroy();
      gameState.placementArrowLeft.destroy();
      gameState.placementArrowRight.destroy();
      gameState.buildMode = null;
      gameState.checkButton.setVisible(false);
      gameState.xButton.setVisible(false);
    } else if (gameState.buildMode === 'shelter' && gameState.sticksCollected >= 7) {
        
      // Deduct branches
      gameState.sticksCollected -= gameState.buildCosts.shelter;
      gameState.stickText.setText(`${gameState.sticksCollected}`);

      // Create actual shelter at placement position
      const shelter = this.add.sprite(
        gameState.placementItem.x,
        gameState.placementItem.y,
        'shelter', 0
      ).setScale(1).setDepth(210);

      this.physics.world.enable(shelter);
      shelter.body.setAllowGravity(false);
      shelter.body.setImmovable(true);
      shelter.body.setSize(128, 128, false);
      shelter.body.setOffset(0, 0);
      shelter.body.isCircle = false;
      
      // Store shelter
      gameState.shelters.push(shelter);

      gameState.placementSound.play(); // Play placement sound

      // Show build notification
      showInfoText('You built a Shelter', 2000);

      // Clean up placement UI
      gameState.placementItem.destroy();
      gameState.placementArrowLeft.destroy();
      gameState.placementArrowRight.destroy();
      gameState.buildMode = null;
      gameState.checkButton.setVisible(false);
      gameState.xButton.setVisible(false);
    }
  });

  gameState.xButton.on('pointerdown', () => {
    if (gameState.buildMode) {
      // Clean up placement UI without deducting branches
      gameState.placementItem.destroy();
      gameState.placementArrowLeft.destroy();
      gameState.placementArrowRight.destroy();
      gameState.buildMode = null;
      gameState.checkButton.setVisible(false);
      gameState.xButton.setVisible(false);
    }
  });

  // Score text (bottom center, currently hidden)
  gameState.scoreText = this.add.text(
    centerX-40,
    this.cameras.main.height*.09,
    'Score: 0',
    { fontSize: '15px', fill: '#000000' }
  );

  // -----------------
  // INPUT SETUP
  // -----------------
  gameState.cursors = this.input.keyboard.createCursorKeys();

  // Add Enter and Backspace key support for building
  gameState.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
  gameState.backspaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.BACKSPACE);
  gameState.bKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B);
  // Debug: inspect branches with I key
  gameState.debugBranchesKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);

  // Debug overlay hidden by default
  gameState.branchDebugText = this.add.text(10, 10, '', {
    fontSize: '14px',
    fill: '#ffffff',
    backgroundColor: 'rgba(0,0,0,0.6)',
    padding: { x: 6, y: 6 }
  }).setDepth(10000).setVisible(false);

  // Enable rain (for testing - can be tied to weather system later)
  gameState.isRaining = true;

  // -----------------
  // PHYSICS COLLIDERS
  // -----------------
  // Player collides with ground
  this.physics.add.collider(gameState.player, gameState.platforms);
  // Player collides with shelter platforms (true physics)
  this.physics.add.collider(gameState.player, gameState.shelterPlatforms);

  // Branches fall and land on ground
  this.physics.add.collider(gameState.branches, gameState.platforms, (branch) => {
    if (!branch.getData('rotated') && !branch.getData('soundPlayed')) {
      // Mark sound as played immediately to prevent multiple plays
      branch.setData('soundPlayed', true);

      // Play placement sound when branch hits ground
      gameState.placementSound.play();

      // Rotate branch to stand upright when it hits ground
      const targetAngle = branch.flipX ? -90 : 90;
      branch.setAngle(targetAngle);
      branch.setScale(1.5);
      branch.y -= 16;

      branch.body.setAllowGravity(false);
      branch.body.setVelocity(0, 0);
      branch.setData('rotated', true);
      branch.setData('collectable', true);

      // Pulsing animation to indicate it's collectible
      this.tweens.add({
        targets: branch,
        scaleX: 1.7,
        scaleY: 1.7,
        yoyo: true,
        repeat: -1,
        duration: 400
      });
    }
  });

  // Player collects branches
  this.physics.add.overlap(gameState.player, gameState.branches, (player, branch) => {
    if (!gameState.isClimbing && branch.getData('collectable')) {
      branch.destroy();
      // Branches are worth the current level
      gameState.sticksCollected += gameState.level;
      gameState.stickText.setText(`${gameState.sticksCollected}`);
      gameState.pickUpItemSound.play();

      // Track branch pickups with time window
      const currentTime = this.time.now;
      if (currentTime - gameState.lastBranchPickupTime > 5000) {
        // More than 5 seconds since last pickup, reset counter
        gameState.branchesPickedInWindow = gameState.level;
        showInfoText(`Picked up ${gameState.level} Branch${gameState.level > 1 ? 'es' : ''}`, 2000);
      } else {
        // Within 5 second window, increment counter
        gameState.branchesPickedInWindow += gameState.level;
        showInfoText(`Picked up ${gameState.branchesPickedInWindow} Branches`, 2000);
      }
      gameState.lastBranchPickupTime = currentTime;
    }
  });

  // -----------------
  // UI BUTTON HANDLERS
  // -----------------
  // Fire icon click - start fire placement
  gameState.buildFireIcon.on('pointerdown', () => {
    if (gameState.sticksCollected >= 3 && !gameState.buildMode) {
      gameState.buildMode = 'fire';

      // Create placement preview
      gameState.placementItem = this.add.sprite(
        centerX,
        this.cameras.main.height - 85,
        'fire_spritesheet'
      ).setScale(1).setDepth(210).setAlpha(0.7);
      gameState.placementItem.anims.play('fireBurn', true);

      // Create arrows
      gameState.placementArrowLeft = this.add.text(
        centerX - 50,
        this.cameras.main.height - 85,
        'â†',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      gameState.placementArrowRight = this.add.text(
        centerX + 50,
        this.cameras.main.height - 85,
        'â†’',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      // Show confirmation buttons just above fire (centered)
      const fireY = this.cameras.main.height - 85;
      gameState.checkButton.x = centerX - 20; // Offset left to center the pair
      gameState.checkButton.y = fireY - 50; // 50 pixels above fire
      gameState.xButton.x = centerX + 20; // Offset right to center the pair
      gameState.xButton.y = fireY - 50;
      gameState.checkButton.setVisible(true);
      gameState.xButton.setVisible(true);
    }
  });

  // Bucket icon click - start bucket placement
  gameState.buildBucketIcon.on('pointerdown', () => {
    if (gameState.sticksCollected >= 5 && !gameState.buildMode) {
      gameState.buildMode = 'bucket';

      // Create placement preview
      gameState.placementItem = this.add.sprite(
        centerX,
        this.cameras.main.height - 85,
        'bucket_spritesheet',
        0
      ).setScale(1).setDepth(210).setAlpha(0.7);

      // Create arrows
      gameState.placementArrowLeft = this.add.text(
        centerX - 50,
        this.cameras.main.height - 85,
        'â†',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      gameState.placementArrowRight = this.add.text(
        centerX + 50,
        this.cameras.main.height - 85,
        'â†’',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      // Show confirmation buttons just above bucket (centered)
      const bucketY = this.cameras.main.height - 85;
      gameState.checkButton.x = centerX - 20; // Offset left to center the pair
      gameState.checkButton.y = bucketY - 50; // 50 pixels above bucket
      gameState.xButton.x = centerX + 20; // Offset right to center the pair
      gameState.xButton.y = bucketY - 50;
      gameState.checkButton.setVisible(true);
      gameState.xButton.setVisible(true);
    }
  });


  // Shelter icon click - start shelter placement
  gameState.buildShelterIcon.on('pointerdown', () => {
    if (gameState.sticksCollected >= 7 && !gameState.buildMode) {
      gameState.buildMode = 'shelter';
      gameState.shelterPreviewFrame = 0;
      showInfoText('Shelter frames: ' + gameState.shelterFrameCount, 3000);
      // Create placement preview (shelter is 128x128, so position it higher to be flush with platform)
      const shelterY = this.cameras.main.height - (64 + 60); // Half height of shelter (64) + platform offset (60)
      gameState.ghostPreviewX = centerX;
      gameState.ghostPreviewY = shelterY;
      gameState.placementItem = this.add.sprite(
        gameState.ghostPreviewX,
        gameState.ghostPreviewY,
        'shelter', gameState.shelterPreviewFrame
      ).setScale(1).setDepth(210).setAlpha(0.7);

      // Create arrows at shelter position
      gameState.placementArrowLeft = this.add.text(
        centerX - 50,
        shelterY,
        'â†',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      gameState.placementArrowRight = this.add.text(
        centerX + 50,
        shelterY,
        'â†’',
        { fontSize: '40px', fill: '#ffffff', fontStyle: 'bold' }
      ).setOrigin(0.5, 0.5).setDepth(210);

      // Show confirmation buttons above shelter (centered)
      gameState.checkButton.x = centerX - 20; // Offset left to center the pair
      gameState.checkButton.y = shelterY - 80; // 80 pixels above shelter center
      gameState.xButton.x = centerX + 20; // Offset right to center the pair
      gameState.xButton.y = shelterY - 80;
      gameState.checkButton.setVisible(true);
      gameState.xButton.setVisible(true);
    }
  });

  // -----------------
  // RAINDROP SETUP
  // -----------------
  gameState.raindrops = this.physics.add.group();

  // Rain generation - spawn raindrops periodically
  this.time.addEvent({
    delay: 100, // Check more frequently for smooth intensity
    callback: () => {

        if (gameState.stormActive) {
        // Rain intensity and speed based on stormStrength (0-1)
        // Reduce spawn count and lower Y velocity so rain falls more slowly visually.
        const drops = Math.round(Phaser.Math.Linear(1, 4, gameState.stormStrength));
        for (let i = 0; i < drops; i++) {
          const xCoord = Math.random() * this.cameras.main.width;
          const randomDepth = 100 + Math.random() * 100;
          const raindrop = gameState.raindrops.create(xCoord, -10, 'raindrop').setScale(0.5).setDepth(randomDepth);
          // Slower fall: 40px/s at light rain -> 120px/s at heavy rain
          raindrop.body.setVelocityY(Phaser.Math.Linear(40, 120, gameState.stormStrength));
        }

        // Occasional log while stormActive to confirm spawn (every ~1s)
        gameState._rainLogTick = (gameState._rainLogTick || 0) + 1;
        if (gameState._rainLogTick % 10 === 0) {
          
        }
      }
    },
    loop: true
  });

  // Raindrop collides with ground - destroy
  this.physics.add.collider(gameState.raindrops, gameState.platforms, function (raindrop) {
    raindrop.destroy();
  });
}

    // Ensure player sprite shows a valid frame and physics is enabled (fallback)
    if (gameState.player) {
      try {
        safeSetTexture(gameState.player, 'spritesheet', 0);
      } catch (e) {}
      try {
        if (!gameState.player.body) this.physics.world.enable(gameState.player);
        if (gameState.player.body) {
          gameState.player.body.setCollideWorldBounds(true);
          gameState.player.body.setAllowGravity(true);
        }
      } catch (e) {}
    }

// =======================
// UPDATE LOOP
// =======================
function update() {
    // Defensive: ensure input cursors exist (prevent runtime crash if create() didn't run yet)
    if (!gameState.cursors || typeof gameState.cursors.space === 'undefined') {
      try { gameState.cursors = this.input.keyboard.createCursorKeys(); } catch (e) {}
    }

      // Defensive: ensure player physics body exists so movement code runs
      if (gameState.player && !gameState.player.body) {
        try {
          this.physics.world.enable(gameState.player);
          if (gameState.player.body && typeof gameState.player.body.setCollideWorldBounds === 'function') {
            gameState.player.body.setCollideWorldBounds(true);
          }
          if (gameState.player.body) gameState.player.body.setAllowGravity(true);
        } catch (e) {}
      }

    // Always enable gravity for player unless climbing (guard player existence)
    if (!gameState.isClimbing && gameState.player && gameState.player.body && gameState.player.body.allowGravity === false) {
      gameState.player.body.setAllowGravity(true);
    }
    // Debug: log active branches when debug key pressed
    if (gameState.debugBranchesKey && Phaser.Input.Keyboard.JustDown(gameState.debugBranchesKey)) {
      const arr = gameState.branches.getChildren().filter(b => b.active).map(b => ({
        x: Math.round(b.x),
        y: Math.round(b.y),
        health: b.getData('health') || 3,
        healing: !!b.getData('healTimer'),
        beingCut: !!b.getData('beingCut'),
        onTree: !!b.getData('onTree'),
        growing: !!b.getData('growing')
      }));
      
    }

    // Per-branch gradual healing: +1 health per second while on tree and not being cut
    if (gameState.branches) {
      gameState.branches.getChildren().forEach(branch => {
        if (!branch || !branch.active) return;

        const health = branch.getData('health') || 0;
        const onTree = !!branch.getData('onTree');
        const beingCut = !!branch.getData('beingCut');
        const existingTimer = branch.getData('healTimer');

        // Only schedule healing for partially damaged branches that are attached,
        // not being cut, and not currently growing (newly regenerated branches).
        if (onTree && !beingCut && health > 0 && health < 3 && !branch.getData('growing')) {
          if (!existingTimer) {
            // Schedule a tick after 1s to add +1 health
            const healTick = () => {
              // Guard: branch may have been destroyed or fallen
              if (!branch || !branch.active) return;

              // If player started cutting this branch, cancel healing
              if (branch.getData('beingCut')) {
                branch.setData('healTimer', null);
                return;
              }

              let h = branch.getData('health') || 0;
              h = Math.min(3, h + 1);
              branch.setData('health', h);

              // Update frame to reflect healed state (use safe helper)
              try {
                const frameIndex = (h === 3) ? 0 : (h === 2) ? 1 : 2;
                safeSetFrame(branch, frameIndex);
              } catch (e) {}

              // Clear this timer record
              branch.setData('healTimer', null);

              // If still not full, schedule another tick
              if (h > 0 && h < 3) {
                const t = gameState.scene.time.delayedCall(1000, healTick);
                branch.setData('healTimer', t);
              }
            };

            const t = gameState.scene.time.delayedCall(1000, healTick);
            branch.setData('healTimer', t);
          }
        } else {
          // Not eligible for healing: ensure no stray timer remains
          if (existingTimer) {
            try { existingTimer.remove(); } catch (e) {}
            branch.setData('healTimer', null);
          }
        }
      });
    }
  // --- GROUND/SHELTER CHECKS (must be at very top of update loop) ---
  // No manual shelter collision logic needed; handled by physics collider
  let onGroundOrShelter = false;
  if (gameState.player && gameState.player.body && typeof gameState.player.body.onFloor === 'function') {
    onGroundOrShelter = gameState.player.body.onFloor();
  }
  // --- HUNGER & THIRST DEPLETION ---
  // Use real time (not frame time) for consistent depletion
  if (!gameState.lastHungerThirstTick) gameState.lastHungerThirstTick = Date.now();
  const now = Date.now();
  if (now - gameState.lastHungerThirstTick >= 5000) {
    if (gameState.hunger > 0) gameState.hunger = Math.max(0, gameState.hunger - 1);
    if (gameState.thirst > 0) gameState.thirst = Math.max(0, gameState.thirst - 1);
    gameState.lastHungerThirstTick += 5000;
  }
              // --- HUNGER & THIRST UI COLOR ---
                          // Determine day/night for UI coloring (night: 6pm-6am)
                          const hourOfDayUI = ((gameState.gameTime || 0) % (24 * 60)) / 60;
                          // Night when before 7:00 or at/after 19:00 to match sun/moon windows
                          const isNightUI = (hourOfDayUI < 7) || (hourOfDayUI >= 19);
                          const uiTextColor = isNightUI ? '#ffffff' : '#000000';

                          // Thirst (water drop) - color thresholds:
                          // 0-5: red, 6-10: orange, 11-20: yellow, >20: green
                          let thirstColor = '#00aa00';
                          if (gameState.thirst <= 5) thirstColor = '#ff0000';
                          else if (gameState.thirst <= 10) thirstColor = '#ff8800';
                          else if (gameState.thirst <= 20) thirstColor = '#ffff00';
                          gameState.waterText.setText(`${gameState.thirst}`);
                          gameState.waterText.setColor(thirstColor);
                          // Keep stroke as originally defined (stay black); only change fill color

                          // Hunger (berry) - same thresholds
                          let hungerColor = '#00aa00';
                          if (gameState.hunger <= 5) hungerColor = '#ff0000';
                          else if (gameState.hunger <= 10) hungerColor = '#ff8800';
                          else if (gameState.hunger <= 20) hungerColor = '#ffff00';
                          gameState.berryText.setText(`${gameState.hunger}`);
                          gameState.berryText.setColor(hungerColor);
                          // Keep stroke as originally defined (stay black); only change fill color

                          // Make all UI text that is normally black switch to white at night.
                          // Update a curated set of known text objects.
                          if (gameState.levelText && gameState.levelText.setColor) gameState.levelText.setColor(uiTextColor);
                          if (gameState.stickText && gameState.stickText.setColor) gameState.stickText.setColor(uiTextColor);
                          if (gameState.buildLabel && gameState.buildLabel.setColor) gameState.buildLabel.setColor(uiTextColor);
                          if (gameState.buildCostText && gameState.buildCostText.setColor) gameState.buildCostText.setColor(uiTextColor);
                          if (gameState.timeText && gameState.timeText.setColor) gameState.timeText.setColor(uiTextColor);
                          if (gameState.tempText && gameState.tempText.setColor) gameState.tempText.setColor(uiTextColor);
                          if (gameState.musicPlayPauseButton && gameState.musicPlayPauseButton.setColor) gameState.musicPlayPauseButton.setColor(uiTextColor);
                          if (gameState.volumeButton && gameState.volumeButton.setColor) gameState.volumeButton.setColor(uiTextColor);
                          if (gameState.scoreText && gameState.scoreText.setColor) gameState.scoreText.setColor(uiTextColor);
            // Clamp all berries to ground after animation so they never fall off the map
            // Adjust so berry bottom sits on ground (berry is 32px tall, scaled 0.6)
            let berryGroundY = h - 94 - (32 * 0.6) / 2;
            if (gameState.platforms && gameState.platforms.getChildren().length > 0) {
              berryGroundY = gameState.platforms.getChildren()[0].y - 26 - (32 * 0.6) / 2;
            }
            gameState.berries.getChildren().forEach(berry => {
              if (berry.y > berryGroundY) {
                berry.y = berryGroundY;
                berry.body && (berry.body.velocity.y = 0);
              }
            });
          // --- BERRY BUSHES ---
          // Calculate deltaTime for berry bush logic
          let berryDeltaTime = 0.016; // fallback default
          if (gameState.lastBerryUpdateTime) {
            berryDeltaTime = (Date.now() - gameState.lastBerryUpdateTime) / 1000;
          }
          gameState.lastBerryUpdateTime = Date.now();

          // Animate berry bushes (cycle through 3 frames)
          gameState.berryBushes.getChildren().forEach(bush => {
            if (!bush.getData('regrowing')) {
              let frame = bush.getData('frame') || 0;
              let timer = bush.getData('frameTimer') || 0;
              timer += berryDeltaTime;
              if (timer > 0.3) { // Change frame every 0.3s
                frame = (frame + 1) % 3;
                try { bush.setFrame(frame); } catch (e) {}
                timer = 0;
              }
              bush.setData('frame', frame);
              bush.setData('frameTimer', timer);
            }
          });

          // Berry picking interaction: use up arrow when overlapping
          if (Phaser.Input.Keyboard.JustDown(gameState.cursors.up) && !gameState.buildMode) {
            gameState.berryBushes.getChildren().forEach(bush => {
              if (!bush.getData('regrowing') && bush.getData('berries') > 0) {
                const dist = Phaser.Math.Distance.Between(
                  gameState.player.x, gameState.player.y, bush.x, bush.y
                );
                if (dist < 60) { // tighter overlap for picking
                  // Play bush sound when picking from bush
                  if (gameState.bushSound) {
                    if (gameState.bushSound.isPlaying) gameState.bushSound.stop();
                    const bushDuration = gameState.bushSound.duration || 1.0;
                    gameState.bushSound.play({ seek: 0 });
                    gameState.scene.time.delayedCall((bushDuration * 0.5) * 1000, () => {
                      if (gameState.bushSound.isPlaying) gameState.bushSound.stop();
                    });
                  }
                  // Animate berry jumping out
                  const berry = gameState.berries.create(bush.x, bush.y - 32, 'berry').setScale(0.6).setDepth(220);
                  const direction = Math.random() < 0.5 ? -1 : 1;
                  const jumpX = berry.x + direction * Phaser.Math.Between(40, 60);
                  const jumpY = berry.y - Phaser.Math.Between(40, 60);
                  gameState.scene.tweens.add({
                    targets: berry,
                    x: jumpX,
                    y: jumpY,
                    duration: 400,
                    ease: 'Cubic.easeOut',
                    yoyo: false,
                    onComplete: () => {
                      // After jump, fall straight down to ground
                      // Clamp berry fall to visible ground (use platform Y or camera height)
                      let groundY = h - 94;
                      if (gameState.platforms && gameState.platforms.getChildren().length > 0) {
                        // Use platform Y if available
                        groundY = gameState.platforms.getChildren()[0].y - 24;
                      }
                      // Adjust so berry bottom sits on ground
                      let berryFallY = groundY - (32 * 0.6) / 2;
                      gameState.scene.tweens.add({
                        targets: berry,
                        y: berryFallY,
                        duration: 300,
                        ease: 'Cubic.easeIn',
                        onComplete: () => {
                          berry.y = berryFallY; // Clamp to ground
                          berry.setDepth(220); // Always above tree
                          berry.setData('canPickup', true);
                        }
                      });
                    }
                  });
                  // Decrement bush berry count
                  bush.setData('berries', bush.getData('berries') - 1);
                  // If bush is empty, start regrowth
                  if (bush.getData('berries') <= 0) {
                    bush.setVisible(false);
                    bush.setData('regrowing', true);
                    gameState.scene.time.delayedCall(10000, () => {
                      // Regrow bush in new valid spot
                      bush.setData('regrowing', false);
                      bush.setData('berries', 10);
                      let tries = 0, x, y;
                      do {
                        x = Phaser.Math.Between(100, w - 100);
                        y = h - 96;
                        tries++;
                      } while (!gameState.scene.isValidBerryBushPosition || !gameState.scene.isValidBerryBushPosition(x, y) && tries < 20);
                      bush.x = x;
                      bush.y = y;
                      bush.setVisible(true);
                    });
                  }
                }
              }
            });
          }

          // Berry pickup logic
          gameState.berries.getChildren().forEach(berry => {
            if (berry.getData('canPickup')) {
              const dist = Phaser.Math.Distance.Between(
                gameState.player.x, gameState.player.y, berry.x, berry.y
              );
              if (dist < 40) {
                berry.destroy();
                // Play pick up item sound when picking up from ground
                if (gameState.pickUpItemSound) {
                  if (gameState.pickUpItemSound.isPlaying) gameState.pickUpItemSound.stop();
                  gameState.pickUpItemSound.play();
                }
                // Add to inventory (increase hunger for now)
                gameState.hunger = Math.min(gameState.hunger + 10, gameState.maxHunger);
                showInfoText('You picked a berry! (+10 hunger)', 1200);
              }
            }
          });
        // --- WEATHER SYSTEM ---
        // --- WEATHER SYSTEM: Precompute daily storms ---
        // Use `gameDay` (set at rollover) when available, otherwise fall back
        // to computed day from gameTime for the very first tick.
        const day = (typeof gameState.gameDay === 'number') ? gameState.gameDay : Math.floor(gameState.gameTime / (24 * 60));
        if (gameState.lastDayChecked !== day) {
          gameState.rainMinutesToday = 0;
          gameState.lastDayChecked = day;
          const dayStart = day * 24 * 60;
          gameState.stormSchedule = gameState.scheduleStormsForDay(dayStart);
          
          gameState.stormIndex = 0;
        }
        // Check if we should start or end a storm based on the schedule
        let nextStorm = gameState.stormSchedule[gameState.stormIndex];
        if (nextStorm && gameState.gameTime >= nextStorm.start && gameState.gameTime < nextStorm.end) {
          if (!gameState.stormActive) {
            gameState.stormActive = true;
            gameState.stormStrength = Math.random();
            gameState.nextStormTime = nextStorm.start;
            gameState.stormEndTime = nextStorm.end;
            
          }
        } else if (nextStorm && gameState.gameTime >= nextStorm.end) {
          if (gameState.stormActive) {
            gameState.stormActive = false;
            gameState.isRaining = false;
            gameState.stormStrength = 0;
            let rainThisStorm = gameState.stormEndTime - gameState.nextStormTime;
            if (rainThisStorm > 0) gameState.rainMinutesToday += rainThisStorm;
          }
          gameState.stormIndex++;
        }
        // (rest of weather logic unchanged)
        if (gameState.stormActive) {
          const stormTotal = gameState.stormEndTime - gameState.nextStormTime;
          const timeLeft = gameState.stormEndTime - gameState.gameTime;
          // If storm is in its last 10% (or last 10 minutes if short), start petering out
          const peterOutDuration = Math.max(10, stormTotal * 0.1); // at least 10 minutes
          let petersOut = false;
          if (timeLeft <= peterOutDuration) {
            petersOut = true;
          }
          // Storm is active: smoothly vary strength
          const t = (gameState.gameTime - gameState.nextStormTime) / stormTotal;
          let base = 0.5 + 0.5 * Math.sin(t * Math.PI * 2 + Math.random() * 0.5);
          // Add a little random walk
          gameState.stormStrength += Phaser.Math.FloatBetween(-0.02, 0.02);
          // If petering out, force stormStrength to decrease smoothly to 0
          if (petersOut) {
            const fade = Phaser.Math.Clamp(timeLeft / peterOutDuration, 0, 1);
            base *= fade;
            gameState.stormStrength = Phaser.Math.Clamp((gameState.stormStrength + base) / 2, 0, fade);
          } else {
            gameState.stormStrength = Phaser.Math.Clamp((gameState.stormStrength + base) / 2, 0, 1);
          }
          gameState.isRaining = gameState.stormStrength > 0.1;
        }
      // --- FOOTSTEPS AUDIO ---
      let movingOnGround = false;
      if (
        gameState.player &&
        gameState.player.body &&
        gameState.player.body.onFloor() &&
        !gameState.isClimbing &&
        !gameState.isCrouching &&
        !gameState.buildMenuOpen &&
        !gameState.buildMode &&
        (gameState.cursors.left.isDown || gameState.cursors.right.isDown)
      ) {
        // Only play if actually moving horizontally
        if (Math.abs(gameState.player.body.velocity.x) > 5) {
          movingOnGround = true;
        }
      }
      if (movingOnGround) {
        if (gameState.footstepsSound && !gameState.footstepsSound.isPlaying) {
          gameState.footstepsSound.play({ seek: 0 }); // Always start from beginning
        }
      } else {
        if (gameState.footstepsSound && gameState.footstepsSound.isPlaying) {
          gameState.footstepsSound.stop();
        }
      }

      // --- RAIN AUDIO ---
      if (gameState.isRaining && gameState.stormStrength > 0.1) {
        if (gameState.rainSound && !gameState.rainSound.isPlaying) {
          gameState.rainSound.play();
        }
      } else {
        if (gameState.rainSound && gameState.rainSound.isPlaying) {
          gameState.rainSound.stop();
        }
      }
    // --- Shelter preview: cycle sprite frame with up arrow ---
    if (gameState.buildMode === 'shelter' && gameState.placementItem) {
      // (moved to after stacking logic)
      // (do nothing here)
    }
  // -----------------
  // TIME & ENVIRONMENT SYSTEM
  // -----------------
  // Calculate delta time for frame-rate independent updates
  const currentTime = Date.now();
  if (!gameState.lastTimeUpdate) gameState.lastTimeUpdate = currentTime;
  const deltaTime = (currentTime - gameState.lastTimeUpdate) / 1000;
  gameState.lastTimeUpdate = currentTime;

  // -----------------
  // BUILD SYSTEM - ICON OPACITY
  // -----------------
  // Update build icon opacity based on affordability
  gameState.buildFireIcon.setAlpha(gameState.sticksCollected >= gameState.buildCosts.fire ? 1 : 0.5);
  gameState.buildBucketIcon.setAlpha(gameState.sticksCollected >= gameState.buildCosts.bucket ? 1 : 0.5);
  gameState.buildShelterIcon.setAlpha(gameState.sticksCollected >= gameState.buildCosts.shelter ? 1 : 0.5);

  // -----------------
  // BUILD MENU SYSTEM
  // -----------------
  // B key toggles build menu
  if (Phaser.Input.Keyboard.JustDown(gameState.bKey) && !gameState.buildMode) {
    gameState.buildMenuOpen = !gameState.buildMenuOpen;

    if (gameState.buildMenuOpen) {
      // Build list of affordable items
      gameState.buildableItems = [];
      if (gameState.sticksCollected >= gameState.buildCosts.fire) {
        gameState.buildableItems.push({ type: 'fire', icon: gameState.buildFireIcon, cost: gameState.buildCosts.fire });
      }
      if (gameState.sticksCollected >= gameState.buildCosts.bucket) {
        gameState.buildableItems.push({ type: 'bucket', icon: gameState.buildBucketIcon, cost: gameState.buildCosts.bucket });
      }
      if (gameState.sticksCollected >= gameState.buildCosts.shelter) {
        gameState.buildableItems.push({ type: 'shelter', icon: gameState.buildShelterIcon, cost: gameState.buildCosts.shelter });
      }

      // If no buildable items, flash red and show message
      if (gameState.buildableItems.length === 0) {
        gameState.buildFireIcon.setTint(0xff0000);
        gameState.buildBucketIcon.setTint(0xff0000);
        gameState.buildShelterIcon.setTint(0xff0000);

        // Show "Nothing to build" message
        showInfoText('Nothing to build', 2000);

        // Remove tint after 1 second
        gameState.scene.time.delayedCall(1000, () => {
          gameState.buildFireIcon.clearTint();
          gameState.buildBucketIcon.clearTint();
          gameState.buildShelterIcon.clearTint();
        });

        gameState.buildMenuOpen = false;
      } else {
        // Select first item if any available
        gameState.buildMenuSelection = 0;

        // Highlight first item (different scales for different icon sizes)
        if (gameState.buildableItems[0].type === 'shelter') {
          gameState.buildableItems[0].icon.setScale(0.3); // 128x128 image
        } else {
          gameState.buildableItems[0].icon.setScale(0.6); // 64x64 images
        }

        // Show build instruction with colored check/x and cost
        const itemName = gameState.buildableItems[0].type === 'fire' ? 'Fire' :
          gameState.buildableItems[0].type === 'bucket' ? 'Bucket' : 'Shelter';
        showBuildMenuText(itemName, gameState.buildableItems[0].cost);

        // Reset jump states to prevent interference
        gameState.spaceHeld = false;
        gameState.isCrouching = false;
        gameState.jumpBufferTime = 0;
      }
    } else {
      // Close menu - reset all icons and hide instruction
      gameState.buildFireIcon.setScale(0.4);
      gameState.buildBucketIcon.setScale(0.4);
      gameState.buildShelterIcon.setScale(0.2);
      hideBuildMenuText();
    }
  }

  // Build menu navigation
  if (gameState.buildMenuOpen && gameState.buildableItems.length > 0 && !gameState.buildMode) {
    // Left/Right arrow keys to cycle through items
    if (Phaser.Input.Keyboard.JustDown(gameState.cursors.left)) {
      gameState.menuSelectionSound.play(); // Play menu selection sound
      // Reset current selection scale
      if (gameState.buildableItems[gameState.buildMenuSelection].type === 'shelter') {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.2);
      } else {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.4);
      }

      // Move selection left (wrap around)
      gameState.buildMenuSelection--;
      if (gameState.buildMenuSelection < 0) {
        gameState.buildMenuSelection = gameState.buildableItems.length - 1;
      }

      // Highlight new selection
      if (gameState.buildableItems[gameState.buildMenuSelection].type === 'shelter') {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.3);
      } else {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.6);
      }

      // Update instruction text with colored check/x
      const itemName = gameState.buildableItems[gameState.buildMenuSelection].type === 'fire' ? 'Fire' :
        gameState.buildableItems[gameState.buildMenuSelection].type === 'bucket' ? 'Bucket' : 'Shelter';
      showBuildMenuText(itemName, gameState.buildableItems[gameState.buildMenuSelection].cost);
    }

    if (Phaser.Input.Keyboard.JustDown(gameState.cursors.right)) {
      gameState.menuSelectionSound.play(); // Play menu selection sound
      // Reset current selection scale
      if (gameState.buildableItems[gameState.buildMenuSelection].type === 'shelter') {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.2);
      } else {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.4);
      }

      // Move selection right (wrap around)
      gameState.buildMenuSelection++;
      if (gameState.buildMenuSelection >= gameState.buildableItems.length) {
        gameState.buildMenuSelection = 0;
      }

      // Highlight new selection
      if (gameState.buildableItems[gameState.buildMenuSelection].type === 'shelter') {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.3);
      } else {
        gameState.buildableItems[gameState.buildMenuSelection].icon.setScale(0.6);
      }

      // Update instruction text with colored check/x
      const itemName = gameState.buildableItems[gameState.buildMenuSelection].type === 'fire' ? 'Fire' :
        gameState.buildableItems[gameState.buildMenuSelection].type === 'bucket' ? 'Bucket' : 'Shelter';
      showBuildMenuText(itemName, gameState.buildableItems[gameState.buildMenuSelection].cost);
    }

    // Enter key to build selected item
    if (Phaser.Input.Keyboard.JustDown(gameState.enterKey)) {
      const selectedItem = gameState.buildableItems[gameState.buildMenuSelection];

      // Trigger the click event on the selected icon
      if (selectedItem.type === 'fire') {
        gameState.buildFireIcon.emit('pointerdown');
      } else if (selectedItem.type === 'bucket') {
        gameState.buildBucketIcon.emit('pointerdown');
      } else if (selectedItem.type === 'shelter') {
        gameState.buildShelterIcon.emit('pointerdown');
      }

      // Close build menu and hide instruction
      gameState.buildMenuOpen = false;
      gameState.buildFireIcon.setScale(0.4);
      gameState.buildBucketIcon.setScale(0.4);
      gameState.buildShelterIcon.setScale(0.2);
      hideBuildMenuText();
    }
  }

  // -----------------
  // PLACEMENT MODE - MOVE ITEM WITH ARROWS
  // -----------------
  if (gameState.buildMode && gameState.placementItem) {
    const moveSpeed =         200 * deltaTime;
    if (gameState.cursors.left.isDown && !gameState.buildMenuOpen) {
      gameState.placementArrowLeft.x -= moveSpeed;
      gameState.placementArrowRight.x -= moveSpeed;
      gameState.checkButton.x -= moveSpeed;
      gameState.xButton.x -= moveSpeed;
      gameState.placementItem.x -= moveSpeed;
      gameState.ghostPreviewX -= moveSpeed;

      
    }
    if (gameState.cursors.right.isDown && !gameState.buildMenuOpen) {
      gameState.placementArrowLeft.x += moveSpeed;
      gameState.placementArrowRight.x += moveSpeed;
      gameState.checkButton.x += moveSpeed;
      gameState.xButton.x += moveSpeed;
      gameState.placementItem.x += moveSpeed;
      gameState.ghostPreviewX += moveSpeed;
    }


    // Prevent movement off screen edges
    let minX = 64;
    let maxX = this.cameras.main.width - 64;
    if (gameState.buildMode === 'bucket' || gameState.buildMode === 'fire') {
      // Allow bucket or fire to be placed so its edge is flush with screen edge (fire is 40px wide)
      minX = 20; // Half object width
      maxX = this.cameras.main.width - 20;
    }
    if (gameState.placementItem.x < minX) {
      gameState.placementItem.x = minX;
      gameState.placementArrowLeft.x = minX - 50;
      gameState.placementArrowRight.x = minX + 50;
      gameState.checkButton.x = minX - 20; // Centered pair offset
      gameState.xButton.x = minX + 20;
    }
    if (gameState.placementItem.x > maxX) {
      gameState.placementItem.x = maxX;
      gameState.placementArrowLeft.x = maxX - 50;
      gameState.placementArrowRight.x = maxX + 50;
      gameState.checkButton.x = maxX - 20; // Centered pair offset
      gameState.xButton.x = maxX + 20;
    }

    // --- Shelter preview stacking & snapping logic ---
    if (gameState.buildMode === 'shelter') {
      const shelterWidth = 128, shelterHeight = 128;

      // Always use ghostPreview as the authoritative preview position
      // placementItem will be updated to match ghostPreview unless we snap
      let shouldSnap = false;
      let snapX = null;
      let snapY = null;
      const snapThresholdX = shelterWidth; // snap only when ghost X is within one shelter width
      const snapThresholdY = 12; // small vertical tolerance for stacking

      for (let i = 0; i < gameState.shelters.length; i++) {
        const existing = gameState.shelters[i];
        const dx = Math.abs(existing.x - gameState.ghostPreviewX);
        const targetY = existing.y - shelterHeight;

        // Snap when ghost X is within horizontal snap threshold of an existing shelter.
        // We intentionally do NOT require the ghostPreviewY to already match targetY so
        // the preview will vertically align (stack) as you pass over an existing shelter.
        if (dx < snapThresholdX) {
          shouldSnap = true;
          snapX = existing.x;
          snapY = targetY;
          break;
        }
      }

      if (shouldSnap) {
        // Snap preview to the stacked position
        gameState.placementItem.x = snapX;
        gameState.placementItem.y = snapY;
        gameState.placementArrowLeft.x = snapX - 50;
        gameState.placementArrowRight.x = snapX + 50;
        gameState.placementArrowLeft.y = snapY;
        gameState.placementArrowRight.y = snapY;
        gameState.checkButton.x = snapX - 20;
        gameState.checkButton.y = snapY - 80;
        gameState.xButton.x = snapX + 20;
        gameState.xButton.y = snapY - 80;
        gameState.snapped = true;
        // Do NOT overwrite ghostPreviewX/Y â€” keep ghost as what player is controlling.
        // The preview sprite is snapped visually, but the ghost coordinates remain authoritative
        // so snapping is temporary while the ghost X/Y stay within the snap range.
        // Visual indicator for snapping
        if (gameState.placementItem.setTint) {
          gameState.placementItem.setTint(0x88ff88);
        }
        gameState.placementItem.setDepth(220);
        // Debug log for snap
        
      } else {
        // Not snapping: ensure preview exactly follows ghostPreview
        gameState.placementItem.x = gameState.ghostPreviewX;
        gameState.placementItem.y = gameState.ghostPreviewY;
        gameState.placementArrowLeft.x = gameState.ghostPreviewX - 50;
        gameState.placementArrowRight.x = gameState.ghostPreviewX + 50;
        gameState.placementArrowLeft.y = gameState.ghostPreviewY;
        gameState.placementArrowRight.y = gameState.ghostPreviewY;
        gameState.checkButton.x = gameState.ghostPreviewX - 20;
        gameState.checkButton.y = gameState.ghostPreviewY - 80;
        gameState.xButton.x = gameState.ghostPreviewX + 20;
        gameState.xButton.y = gameState.ghostPreviewY - 80;
        gameState.snapped = false;
        // Clear any snap tint
        if (gameState.placementItem.clearTint) {
          gameState.placementItem.clearTint();
        }
        gameState.placementItem.setDepth(210);
      }
    }
    // Allow cycling shelter preview frame with up arrow after all position logic
      if (gameState.buildMode === 'shelter' && gameState.placementItem) {
      if (Phaser.Input.Keyboard.JustDown(gameState.cursors.up)) {
        gameState.shelterPreviewFrame = (gameState.shelterPreviewFrame + 1) % gameState.shelterFrameCount;
        safeSetFrame(gameState.placementItem, gameState.shelterPreviewFrame);
      }
    }


    // Enter key - confirm placement (same as check button)
    if (Phaser.Input.Keyboard.JustDown(gameState.enterKey)) {
      if (gameState.buildMode === 'fire' && gameState.sticksCollected >= 3) {
        // Deduct branches
        gameState.sticksCollected -= gameState.buildCosts.fire;
        gameState.stickText.setText(`${gameState.sticksCollected}`);

        // Create actual fire at placement position
        const fire = gameState.scene.add.sprite(
          gameState.placementItem.x,
          gameState.placementItem.y,
          'fire_spritesheet'
        ).setScale(1).setDepth(215);

        gameState.scene.physics.world.enable(fire);
        fire.body.setAllowGravity(false);
        fire.body.setImmovable(true);
        fire.body.setSize(40, 40);
        fire.anims.play('fireBurn', true);
        gameState.fires.push(fire);

        // Play start fire sound (will chain to looping fire sound on complete)
        gameState.startFireSound.play();

        // Show build notification
        showInfoText('You built a Fire', 2000);

        // Clean up placement UI
        gameState.placementItem.destroy();
        gameState.placementArrowLeft.destroy();
        gameState.placementArrowRight.destroy();
        gameState.buildMode = null;
        gameState.checkButton.setVisible(false);
        gameState.xButton.setVisible(false);
      } else if (gameState.buildMode === 'bucket' && gameState.sticksCollected >= 5) {
        // Deduct branches
        gameState.sticksCollected -= gameState.buildCosts.bucket;
        gameState.stickText.setText(`${gameState.sticksCollected}`);

        // Create actual bucket at placement position
        const bucket = gameState.scene.add.sprite(
          gameState.placementItem.x,
          gameState.placementItem.y,
          'bucket_spritesheet',
          0
        ).setScale(1).setDepth(210);

        gameState.scene.physics.world.enable(bucket);
        bucket.body.setAllowGravity(false);
        bucket.body.setImmovable(true);
        bucket.body.setSize(40, 40);

        // Add fill percentage data and text display
        bucket.setData('fillPercent', 0);
        const fillText = gameState.scene.add.text(
          bucket.x,
          bucket.y - 40,
          '0%',
          { fontSize: '16px', fill: '#ffffff', fontStyle: 'bold', stroke: '#000000', strokeThickness: 3 }
        ).setOrigin(0.5).setDepth(210);
        bucket.setData('fillText', fillText);

        // Store bucket for rain collection
        gameState.buckets.push(bucket);

        gameState.scene.sound.play('placement'); // Play placement sound

        // Show build notification
        showInfoText('You built a Bucket', 2000);

        // Clean up placement UI
        gameState.placementItem.destroy();
        gameState.placementArrowLeft.destroy();
        gameState.placementArrowRight.destroy();
        gameState.buildMode = null;
        gameState.checkButton.setVisible(false);
        gameState.xButton.setVisible(false);
      } else if (gameState.buildMode === 'shelter' && gameState.sticksCollected >= 7) {
        // Deduct branches
        gameState.sticksCollected -= gameState.buildCosts.shelter;
        gameState.stickText.setText(`${gameState.sticksCollected}`);

        // Determine final placement coordinates.
        // If preview is currently snapped (temporary visual snap), place at the snapped preview coords.
        // Otherwise place at the authoritative ghost preview position the player controls.
        let finalX, finalY;
        if (gameState.snapped && gameState.placementItem) {
          finalX = gameState.placementItem.x;
          finalY = gameState.placementItem.y;
        } else {
          finalX = gameState.ghostPreviewX;
          finalY = gameState.ghostPreviewY;
        }
        const shelterFrame = gameState.shelterPreviewFrame || 0;
        const shelter = gameState.scene.add.sprite(
          finalX,
          finalY,
          'shelter', shelterFrame
        ).setScale(1).setDepth(210)

        gameState.scene.physics.world.enable(shelter);
        shelter.body.setAllowGravity(false);
        shelter.body.setImmovable(true);
        shelter.body.setSize(128, 128, false);
        shelter.body.setOffset(0, 0);
        shelter.body.isCircle = false;

        

        // If for some reason the code reaches here and placement wasn't done at the snapped preview,
        // keep the shelter where the preview indicated (finalX/finalY). We do NOT force stacking
        // during confirmation â€” stacking only occurs while previewing (temporary snap).


        // Store shelter
        gameState.shelters.push(shelter);

        // Add a static physics platform at the top of the shelter for true collision
        if (gameState.shelterPlatforms) {
          const platform = gameState.shelterPlatforms.create(
            shelter.x,
            shelter.y - 64 + 12, // Slightly lower to match sprite edge
            'platform'
          );
          platform.displayWidth = 128;
          platform.displayHeight = 24; // Thicker for reliable collision
          platform.setAlpha(0); // Invisible platform
          platform.setDepth(9999); // Bring to front
          platform.refreshBody();
          
        }

        gameState.scene.sound.play('placement'); // Play placement sound

        // Show build notification
        showInfoText('You built a Shelter', 2000);

        // Clean up placement UI
        gameState.placementItem.destroy();
        gameState.placementArrowLeft.destroy();
        gameState.placementArrowRight.destroy();
        gameState.buildMode = null;
        gameState.checkButton.setVisible(false);
        gameState.xButton.setVisible(false);
      }
    }

    // Backspace key - cancel placement (same as x button)
    if (Phaser.Input.Keyboard.JustDown(gameState.backspaceKey) && gameState.buildMode) {
      // Clean up placement UI without deducting branches
      gameState.placementItem.destroy();
      gameState.placementArrowLeft.destroy();
      gameState.placementArrowRight.destroy();
      gameState.buildMode = null;
      gameState.checkButton.setVisible(false);
      gameState.xButton.setVisible(false);
    }
  }

  // -----------------
  // RAIN & BUCKET WATER COLLECTION
  // -----------------
  // Check raindrop collisions with player (resets temperature)
  gameState.raindrops.getChildren().forEach(raindrop => {
    if (raindrop && raindrop.active) {
      const distanceToPlayer = Phaser.Math.Distance.Between(
        raindrop.x,
        raindrop.y,
        gameState.player.x,
        gameState.player.y
      );

      if (distanceToPlayer < 30) { // Collision with player
        raindrop.destroy();
        // Reset player temperature to 74 degrees (comfortable)
        gameState.playerTemp = 74;
        gameState.gulpSound.play(); // Play gulp sound when rain hits player

        // Show temperature stabilized message below temp status
        gameState.tempStatusMessage.setText('Temperature Stabilized');
        gameState.tempStatusMessage.setVisible(true);
        gameState.scene.time.delayedCall(2000, () => {
          gameState.tempStatusMessage.setVisible(false);
        });
      }

      // Check raindrop collision with shelters (destroys rain)
      let raindropDestroyed = false;
      gameState.shelters.forEach(shelter => {
        if (shelter && shelter.active && !raindropDestroyed) {
          const distanceToShelter = Phaser.Math.Distance.Between(
            raindrop.x,
            raindrop.y,
            shelter.x,
            shelter.y
          );

          if (distanceToShelter < 40) { // Collision with shelter
            raindrop.destroy();
            if (gameState.raindrops && gameState.raindrops.contains(raindrop)) {
              gameState.raindrops.remove(raindrop, true, true);
            }
            // If you have a trail/particle effect, stop or destroy it here
            raindropDestroyed = true;
          }
        }
      });

      // Check raindrop collision with fires (puts them out) - only if not already destroyed by shelter
      if (!raindropDestroyed) {
        gameState.fires.forEach(fire => {
          if (fire && fire.active) {
            const distanceToFire = Phaser.Math.Distance.Between(
              raindrop.x,
              raindrop.y,
              fire.x,
              fire.y
            );

            if (distanceToFire < 30) { // Collision with fire
              raindrop.destroy();
              fire.destroy();

              // Play fire out sound if it exists
              if (gameState.fireOutSound) {
                gameState.fireOutSound.play();
              }

              // Remove fire from array
              const fireIndex = gameState.fires.indexOf(fire);
              if (fireIndex > -1) {
                gameState.fires.splice(fireIndex, 1);
              }

              // Stop fire sound if no fires remain
              if (gameState.fires.length === 0) {
                gameState.fireSound.stop();
              }
            }
          }
        });
      }
    }
  });

  // Check raindrop collisions with buckets
  gameState.buckets.forEach(bucket => {
    if (bucket && bucket.active) {
      gameState.raindrops.getChildren().forEach(raindrop => {
        if (raindrop && raindrop.active) {
          // Check if raindrop is within bucket bounds
          const distance = Phaser.Math.Distance.Between(
            raindrop.x,
            raindrop.y,
            bucket.x,
            bucket.y
          );

          if (distance < 30) { // Collision threshold
            raindrop.destroy();
            gameState.waterDropSound.play(); // Play water drop sound when rain hits bucket

            // Increase fill percentage
            let fillPercent = bucket.getData('fillPercent') || 0;
            fillPercent = Math.min(fillPercent + 10, 100); // Add 10%, max 100%
            bucket.setData('fillPercent', fillPercent);

            // Update bucket sprite based on fill level (frames 0-4)
            if (fillPercent >= 100) {
              safeSetFrame(bucket, 4); // Full bucket (frame 4)
              gameState.waterCollected++;
              gameState.waterText.setText(`${gameState.waterCollected}`);
              fillPercent = 0; // Reset for next fill
              bucket.setData('fillPercent', 0);
              safeSetFrame(bucket, 0); // Reset to empty (frame 0)
            } else if (fillPercent >= 75) {
              safeSetFrame(bucket, 3); // 75% full
            } else if (fillPercent >= 50) {
              safeSetFrame(bucket, 2); // 50% full
            } else if (fillPercent >= 25) {
              safeSetFrame(bucket, 1); // 25% full
            } else {
              safeSetFrame(bucket, 0); // Empty
            }

            // Update percentage text
            const fillText = bucket.getData('fillText');
            if (fillText) {
              fillText.setText(`${fillPercent}%`);
            }
          }
        }
      });
    }
  });

  // Update game time (24 in-game minutes per real second)
  // This makes a full 24h day pass in 60 seconds (1 minute) of real time
  // â€” 30s for daytime (12h) and 30s for nighttime (12h).
  gameState.gameTime += deltaTime * 24; // 24 minutes per real second
  // Advance day only when a full 24 hours has passed since `dayStart`.
  // This ensures days start at 7:00 and last a full 24 hours.
  const minutesPerDay = 24 * 60;
  const elapsedSinceDayStart = gameState.gameTime - (gameState.dayStart || gameState.gameTime);
  if (elapsedSinceDayStart >= minutesPerDay) {
    // How many full days have passed since dayStart (usually 1)
    const fullDays = Math.floor(elapsedSinceDayStart / minutesPerDay);

    // Advance the recorded dayStart by the number of full days
    gameState.dayStart = (gameState.dayStart || gameState.gameTime) + fullDays * minutesPerDay;

    // Advance gameDay and level once per full day passed
    gameState.gameDay = (gameState.gameDay || 0) + fullDays;
    gameState.level = (gameState.level || 1) + fullDays;

    // Double build costs every other level (on odd levels > 1)
    if (gameState.level > 1 && gameState.level % 2 === 1) {
      gameState.buildCosts.fire *= 2;
      gameState.buildCosts.bucket *= 2;
      gameState.buildCosts.shelter *= 2;
    }

    // Snap gameTime to the new day start (so in-day clock equals 7:00)
    //gameState.gameTime = gameState.dayStart;

    showInfoText(`Level Up! Level ${gameState.level}`); 
    gameState.levelText.setText(`Level: ${gameState.level}`);
  }

  // Display time in 12-hour format
  const hours = Math.floor((gameState.gameTime % (24 * 60)) / 60);
  const minutes = Math.floor(gameState.gameTime % 60);
  const displayHours = hours === 0 ? 12 : (hours > 12 ? hours - 12 : hours);
  const ampm = hours < 12 ? 'AM' : 'PM';
  gameState.timeText.setText(`${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`);

  // Calculate ambient temperature from keypoints with smooth cosine interpolation.
  // Requirements:
  // - Coldest time at 1:00 (choose a reasonable min, previously ~48Â°F)
  // - Sunrise at 7:00 -> 65Â°F
  // - Hottest time at 13:00 (peak, choose previous max ~100Â°F)
  // - Sunset at 19:00 -> 75Â°F
  const hourOfDay = (gameState.gameTime % (24 * 60)) / 60;

  // Define keypoints (hours) and target temps. We include 25 (1am next day)
  // so interpolation across midnight works naturally.
  const Tmin = 48; // coldest at 1:00
  const Tmax = 100; // hottest at 13:00
  const keypoints = [
    { h: 1, temp: Tmin },
    { h: 7, temp: 65 },
    { h: 13, temp: Tmax },
    { h: 19, temp: 75 },
    { h: 25, temp: Tmin } // mirror of 1:00 next day
  ];

  // Map hour into [1,25) domain so values before 1:00 wrap to 25-based span
  let hh = hourOfDay;
  if (hh < 1) hh += 24;

  // Find segment
  let segA = keypoints[0];
  let segB = keypoints[1];
  for (let i = 0; i < keypoints.length - 1; i++) {
    if (hh >= keypoints[i].h && hh < keypoints[i + 1].h) {
      segA = keypoints[i];
      segB = keypoints[i + 1];
      break;
    }
  }

  const span = segB.h - segA.h;
  const frac = span > 0 ? (hh - segA.h) / span : 0;
  // Cosine easing for smooth start/stop
  const mu2 = (1 - Math.cos(frac * Math.PI)) / 2;
  gameState.temperature = segA.temp * (1 - mu2) + segB.temp * mu2;
  gameState.tempText.setText(`${Math.round(gameState.temperature)}Â°F`);

  // -----------------
  // FIRE WARMING SYSTEM
  // -----------------
  // Check distance to all active fires
  gameState.nearFire = false;
  let closestFireDistance = Infinity;
  let touchingFire = false;
  const playerBodyLength = 64;

  gameState.fires.forEach(fire => {
    if (fire && fire.active) {
      const distance = Phaser.Math.Distance.Between(
        gameState.player.x,
        gameState.player.y,
        fire.x,
        fire.y
      );

      if (distance < closestFireDistance) {
        closestFireDistance = distance;
      }

      // Check if touching fire (< 30px)
      if (distance < 30) {
        touchingFire = true;
        if (!gameState.isClimbing && !gameState.isJumping) {
          safeSetTexture(gameState.player, 'fire_player');
        }
      }

      // Check if within warming range (< 128px)
      if (distance < playerBodyLength * 2) {
        gameState.nearFire = true;
      }
    }
  });

  // Reset player sprite when not near fire
  if (!touchingFire && !gameState.isClimbing && !gameState.isJumping &&
    !gameState.isCrouching && gameState.player.texture.key === 'fire_player') {
    safeSetTexture(gameState.player, 'spritesheet', 0);
  }

  // Calculate target temperature based on fire proximity
    // Check if player is under any shelter
    let underShelter = false;
    if (gameState.shelters && gameState.shelters.length > 0) {
      const playerBounds = gameState.player.getBounds();
      for (const shelter of gameState.shelters) {
        if (shelter.active && Phaser.Geom.Intersects.RectangleToRectangle(playerBounds, shelter.getBounds())) {
          underShelter = true;
          break;
        }
      }
    }
  // Base ambient temperature
  let ambientTemp = gameState.temperature;

  // Check if player is under tree (tree shade provides cooling)
  // Bounds will be calculated later for climbing, so we reuse that check
  const tempPlayerBounds = gameState.player.getBounds();
  const tempTrunkBounds = gameState.treeTrunk.getBounds();
  const underTree = Phaser.Geom.Intersects.RectangleToRectangle(tempPlayerBounds, tempTrunkBounds);

  // Shade baseline: immediate effect when under tree.
  // If ambient > 95, shade keeps player at 95 (on cusp of overheating).
  // Else shade sets player to ambient - 10 (protects from heat but not from cold).
  let shadeBaseline = ambientTemp;
  if (underTree) {
    if (ambientTemp > 95) shadeBaseline = 95;
    else shadeBaseline = ambientTemp - 10;
  }

  // Initial target temperature defaults to shade baseline (or ambient when not under tree)
  let targetTemp = shadeBaseline;

  if (gameState.nearFire && closestFireDistance < playerBodyLength * 2) {
    if (touchingFire) {
      // Touching fire: dangerous, accumulating heat
      if (!gameState.fireContactTime) gameState.fireContactTime = 0;
      gameState.fireContactTime += deltaTime;
      const fireBonus = 15 + gameState.fireContactTime;
      // Apply fire bonus on top of shade baseline so fires can heat players in shade
      targetTemp = shadeBaseline + fireBonus;

      // Show warning message periodically (every 3 seconds)
      const currentTime = gameState.scene.time.now;
      if (currentTime - gameState.lastTempWarningTime > 3000) {
        let tempStatus = 'Comfortable';
        if (gameState.playerTemp < 55) tempStatus = 'Freezing';
        else if (gameState.playerTemp < 65) tempStatus = 'Cold';
        else if (gameState.playerTemp > 85) tempStatus = 'Hot';
        else if (gameState.playerTemp > 95) tempStatus = 'Overheating';

        showInfoText(`You are ${tempStatus}`, 2000);
        gameState.lastTempWarningTime = currentTime;
      }
    } else if (closestFireDistance < playerBodyLength) {
      // Within 1 body length: safe warming (+15Â°F)
      targetTemp = shadeBaseline + 15;
    } else {
      // Between 1-2 body lengths: gradient warming
      const distanceRatio = (closestFireDistance - playerBodyLength) / playerBodyLength;
      const fireBonus = 15 * (1 - distanceRatio);
      targetTemp = shadeBaseline + fireBonus;
    }
  } else {
    gameState.fireContactTime = 0;
  }

  // -----------------
  // PLAYER TEMPERATURE REGULATION
  // -----------------
  // Adjust player temperature toward target
  if (underShelter) {
    // Move 15 degrees per second toward 75
    const toward = 75;
    const diff = toward - gameState.playerTemp;
    if (Math.abs(diff) > 0.5) {
      // Move up to 15 degrees per second toward 75
      const change = Math.sign(diff) * Math.min(Math.abs(diff), 15 * deltaTime);
      gameState.playerTemp += change;
    }
  } else if (gameState.nearFire) {
    const tempDifference = targetTemp - gameState.playerTemp;
    // When near fire, adjust faster to match rapid ambient shifts (scaled for compressed time)
    if (Math.abs(tempDifference) > 0.5) {
      gameState.playerTemp += Math.sign(tempDifference) * deltaTime * 6; // faster change
    }
  } else if (underTree) {
    // Under tree shade - gradually adjust to cooler target temp
    const tempDifference = targetTemp - gameState.playerTemp;
    if (Math.abs(tempDifference) > 0.5) {
      gameState.playerTemp += Math.sign(tempDifference) * deltaTime * 2; // slightly faster than before
    }
  } else {
    // Gradually return to ambient temperature
    const diff = gameState.temperature - gameState.playerTemp;
    if (Math.abs(diff) > 0.25) {
      // Passive adjustment tuned for compressed day/night (faster than before)
      const change = Math.sign(diff) * Math.min(Math.abs(diff), 3 * deltaTime);
      gameState.playerTemp += change;
    } else {
      gameState.playerTemp = gameState.temperature;
    }
  }

  // Clamp player temperature to ambient min/max if available, else use sensible defaults
  try {
    if (typeof Tmin !== 'undefined' && typeof Tmax !== 'undefined') {
      gameState.playerTemp = Phaser.Math.Clamp(gameState.playerTemp, Tmin, Tmax);
    } else {
      if (gameState.playerTemp < 50) gameState.playerTemp = 50;
      if (gameState.playerTemp > 120) gameState.playerTemp = 120;
    }
  } catch (e) {
    if (gameState.playerTemp < 50) gameState.playerTemp = 50;
    if (gameState.playerTemp > 120) gameState.playerTemp = 120;
  }

  // -----------------
  // HEALTH DAMAGE FROM TEMPERATURE
  // -----------------
  if (gameState.playerTemp < 55) {
    // Freezing damage
    gameState.health -= deltaTime * 1;
  } else if (gameState.playerTemp > 95) {
    // Heat damage (scales with temperature)
    const degreesOver95 = gameState.playerTemp - 95;
    gameState.health -= deltaTime * degreesOver95;
  }

  // Clamp health
  if (gameState.health < 0) gameState.health = 0;
  if (gameState.health > gameState.maxHealth) gameState.health = gameState.maxHealth;

  // Update player temperature status text (only show 3 states to the player)
  // Internal temperature values still affect health, but UI simplifies to
  // Comfortable / Melting / Freezing so player knows if health is at risk.
  let tempStatus, tempColor;
  if (gameState.playerTemp >= 95) {
    tempStatus = 'Melting';
    tempColor = '#ff0000';
  } else if (gameState.playerTemp <= 55) {
    tempStatus = 'Freezing';
    tempColor = '#0044ff';
  } else {
    tempStatus = 'Comfortable';
    tempColor = '#00aa00';
  }
  gameState.playerTempText.setText(tempStatus);
  gameState.playerTempText.setColor(tempColor);

  // Update health bar visuals
  const centerX = this.cameras.main.width / 2;
  const healthBarX = centerX - 75; // Centered position
  const healthBarY = 50; // Below level text
  const healthBarWidth = 150;
  const healthBarHeight = 20;
  const healthPercent = gameState.health / gameState.maxHealth;

  // Clear and redraw health bar
  gameState.healthBar.clear();

  // Color gradient based on health (pastel green -> yellow -> red)
  let healthColor;
  if (healthPercent > 0.6) {
    healthColor = 0x90ee90; // Pastel green
  } else if (healthPercent > 0.3) {
    healthColor = 0xffff00; // Yellow
  } else {
    healthColor = 0xff0000; // Red
  }

  gameState.healthBar.fillStyle(healthColor, 1);
  gameState.healthBar.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);

  // Update health text
  gameState.healthText.setText(`${Math.round(gameState.health)}/${gameState.maxHealth}`);

  // If health reaches zero, show game over screen and stop updating
  if (gameState.health <= 0 && !gameState.isGameOver) {
    // Diagnostic log to help trace unexpected midnight game overs
    try {
      const displayHour = Math.floor((gameState.gameTime % (24 * 60)) / 60);
      
    } catch (e) {}
    showGameOver(this);
    return; // stop the rest of update loop while game over
  }

  // Sky color transitions based on time
  let skyColor;
  if (hourOfDay >= 6 && hourOfDay < 7) { // 6-7 AM: Sunrise (orange gradient)
    const t = (hourOfDay - 6);
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0x1a1a3e), // Dark blue
      Phaser.Display.Color.ValueToColor(0xff8c42), // Orange
      1, t
    );
  } else if (hourOfDay >= 7 && hourOfDay < 9) { // 7-9 AM: Morning (orange to blue)
    const t = (hourOfDay - 7) / 2;
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0xff8c42), // Orange
      Phaser.Display.Color.ValueToColor(0x87ceeb), // Sky blue
      1, t
    );
  } else if (hourOfDay >= 9 && hourOfDay < 18) { // 9 AM - 6 PM: Day (blue)
    skyColor = Phaser.Display.Color.ValueToColor(0x87ceeb);
  } else if (hourOfDay >= 18 && hourOfDay < 19) { // 6-7 PM: Sunset (blue to red)
    const t = (hourOfDay - 18);
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0x87ceeb), // Sky blue
      Phaser.Display.Color.ValueToColor(0xff6b6b), // Red
      1, t
    );
  } else if (hourOfDay >= 19 && hourOfDay < 20) { // 7-8 PM: Dusk (red to purple)
    const t = (hourOfDay - 19);
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0xff6b6b), // Red
      Phaser.Display.Color.ValueToColor(0x9b59b6), // Purple
      1, t
    );
  } else if (hourOfDay >= 20 && hourOfDay < 22) { // 8-10 PM: Twilight (purple to dark purple)
    const t = (hourOfDay - 20) / 2;
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0x9b59b6), // Purple
      Phaser.Display.Color.ValueToColor(0x2c1a4d), // Dark purple
      1, t
    );
  } else if (hourOfDay >= 22 || hourOfDay < 5) { // 10 PM - 5 AM: Night (dark purple)
    skyColor = Phaser.Display.Color.ValueToColor(0x2c1a4d);
  } else if (hourOfDay >= 5 && hourOfDay < 6) { // 5-6 AM: Pre-dawn (dark purple to dark blue)
    const t = (hourOfDay - 5);
    skyColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      Phaser.Display.Color.ValueToColor(0x2c1a4d), // Dark purple
      Phaser.Display.Color.ValueToColor(0x1a1a3e), // Dark blue
      1, t
    );
  }

  // Get screen dimensions
  const screenWidth = this.cameras.main.width;
  const screenHeight = this.cameras.main.height;

  if (skyColor) {
    this.cameras.main.setBackgroundColor(Phaser.Display.Color.GetColor(skyColor.r, skyColor.g, skyColor.b));

    // Draw horizon gradient - distant land behind tree
    gameState.horizon.clear();
    const horizonHeight = 300; // Height of distant land
    const grassY = screenHeight - (36 * 2) - 35; // Where grass starts
    const horizonY = grassY - horizonHeight + 1; // Start horizon 1px higher to avoid visible line

    // Create gradient from sky color to ground color (gives depth)
    for (let i = 0; i < horizonHeight; i++) {
      const progress = i / horizonHeight;
      // Blend from sky color to earth/grass tones
      const earthColor = Phaser.Display.Color.Interpolate.ColorWithColor(
        skyColor,
        Phaser.Display.Color.ValueToColor(0x5a6b3a), // Olive/grass earth tone
        horizonHeight, i
      );
      const color = Phaser.Display.Color.GetColor(earthColor.r, earthColor.g, earthColor.b);
      gameState.horizon.fillStyle(color, 1);
      gameState.horizon.fillRect(0, horizonY + i, screenWidth, 1);
    }
  }

  // Sun and Moon positioning - simple constant velocity
  const hourOfDaySunMoon = (gameState.gameTime % (24 * 60)) / 60;
  
  // Sun visible from 6 AM to 6 PM (hours 6-18)
  if (hourOfDaySunMoon >= 6 && hourOfDaySunMoon < 18) {
    gameState.sun.setVisible(true);
    gameState.moon.setVisible(false);
    // Move sun left to right across 12 hours
    const sunProgress = (hourOfDaySunMoon - 6) / 12;
    gameState.sun.x = sunProgress * screenWidth;
    gameState.sun.y = screenHeight * 0.2;
  } else {
    // Moon visible from 6 PM to 6 AM
    gameState.sun.setVisible(false);
    gameState.moon.setVisible(true);
    let moonProgress;
    if (hourOfDaySunMoon >= 18) {
      moonProgress = (hourOfDaySunMoon - 18) / 12;
    } else {
      moonProgress = (hourOfDaySunMoon + 6) / 12;
    }
    gameState.moon.x = moonProgress * screenWidth;
    gameState.moon.y = screenHeight * 0.2;
  }

  // -----------------
  // TEMPERATURE ZONES & WARMTH
  // -----------------
  // Check distance to all active fires

  // Check if player is overlapping with tree trunk using bounds
  const playerBounds = gameState.player.getBounds();
  const trunkBounds = gameState.treeTrunk.getBounds();
  const onTree = Phaser.Geom.Intersects.RectangleToRectangle(playerBounds, trunkBounds);

  // Calculate overlap percentage (based on player width)
  let overlapPercent = 0;
  if (onTree) {
    const overlapLeft = Math.max(playerBounds.x, trunkBounds.x);
    const overlapRight = Math.min(playerBounds.right, trunkBounds.right);
    const overlapWidth = overlapRight - overlapLeft;
    overlapPercent = overlapWidth / playerBounds.width;
  }

  // Start climbing when at least 50% overlapping and pressing up
  if (overlapPercent >= 0.75 && gameState.cursors.up.isDown && !gameState.isClimbing && !gameState.buildMode) {
    gameState.isClimbing = true;
    // Snap player to center of tree trunk
    gameState.player.x = gameState.treeTrunk.x;
    gameState.player.setVelocityX(0); // Stop horizontal movement
    // Disable gravity on the player's body while climbing to prevent drift
    if (gameState.player.body) gameState.player.body.setAllowGravity(false);
    gameState.player.setVelocityY(-200); // Start moving up immediately
    gameState.player.anims.play('sawSpin', true); // Start saw animation
    gameState.player.setFlipX(false); // Reset to face forward/left
  }

  // Stop climbing when touching ground
  if (gameState.isClimbing && gameState.player.body.onFloor()) {
    gameState.isClimbing = false;
    gameState.player.anims.stop(); // Stop saw animation
    safeSetTexture(gameState.player, 'spritesheet', 0); // Reset to default spritesheet and frame
    if (gameState.player.body) gameState.player.body.setAllowGravity(true); // Restore normal gravity
    // Stop saw audio if still playing
    if (gameState.sawAttack && gameState.sawAttack.isPlaying) gameState.sawAttack.stop();
    if (gameState.sawSustainLoop && gameState.sawSustainLoop.isPlaying) gameState.sawSustainLoop.stop();
    gameState.sawSoundPlaying = false;
  }

  // If player leaves the tree while climbing, stop climbing and audio
  if (gameState.isClimbing && !onTree) {
    gameState.isClimbing = false;
    try { gameState.player.anims.stop(); } catch (e) {}
    safeSetTexture(gameState.player, 'spritesheet', 0);
    if (gameState.player.body) gameState.player.body.setAllowGravity(true);
    if (gameState.sawAttack && gameState.sawAttack.isPlaying) gameState.sawAttack.stop();
    if (gameState.sawSustainLoop && gameState.sawSustainLoop.isPlaying) gameState.sawSustainLoop.stop();
    gameState.sawSoundPlaying = false;
  }

  // Jump mechanics (only when not climbing, not in build mode, and not in build menu)
  if (!gameState.isClimbing && !gameState.buildMode && !gameState.buildMenuOpen && gameState.player && gameState.player.body && gameState.cursors) {
    // Up key - drink water (when on ground or shelter and have water)
    if (gameState.cursors.up.isDown && onGroundOrShelter && gameState.waterCollected > 0) {
      // Check if not already drinking (prevent spam)
      if (!gameState.isDrinking) {
        gameState.isDrinking = true;
        gameState.waterCollected--;
        gameState.waterText.setText(`${gameState.waterCollected}`);
        // Reset player temperature to 74 degrees (comfortable)
        gameState.playerTemp = 74;
        gameState.gulpSound.play(); // Play gulp sound when drinking

        // Show temperature stabilized message below temp status
        gameState.tempStatusMessage.setText('Temperature Stabilized');
        gameState.tempStatusMessage.setVisible(true);
        gameState.scene.time.delayedCall(2000, () => {
          gameState.tempStatusMessage.setVisible(false);
        });

        // Reset drinking flag after short delay
        gameState.scene.time.delayedCall(500, () => {
          gameState.isDrinking = false;
        });
      }
    }

    // Holding space bar - crouch (frame 1) and charge jump
    if (gameState.cursors.space.isDown && onGroundOrShelter && !gameState.spaceHeld && !gameState.isJumping) {
      gameState.spaceHeld = true;
      gameState.isCrouching = true;
      safeSetTexture(gameState.player, 'spritesheet', 1);
      gameState.jumpChargeStartTime = Date.now(); // Track when charging started

      // Play crouch sound when starting crouch
      if (!gameState.crouchSound.isPlaying) {
        gameState.crouchSound.play();
      }
    }

    // Continue playing crouch sound while holding space in crouch
    if (gameState.cursors.space.isDown && gameState.isCrouching) {
      // Keep playing crouch sound if not already playing
      if (!gameState.crouchSound.isPlaying) {
        gameState.crouchSound.play();
      }
    }

    // Reset spaceHeld when space released
    if (!gameState.cursors.space.isDown && gameState.spaceHeld) {
      // Stop crouch sound when releasing space
      if (gameState.crouchSound.isPlaying) {
        gameState.crouchSound.stop();
      }
    }

    // Released space bar - initiate jump (with coyote time and jump buffer)
    const canJump = onGroundOrShelter || gameState.coyoteTime > 0;

    if (!gameState.cursors.space.isDown && gameState.spaceHeld && canJump) {
      gameState.spaceHeld = false;
      gameState.isCrouching = false;
      gameState.isJumping = true;
      gameState.hasLeftGround = false;
      gameState.jumpStartVelocityX = gameState.player.body.velocity.x;

      // Charged jump logic (as before shelter physics refactor)
      const holdDuration = Date.now() - gameState.jumpChargeStartTime;
      const minJumpVelocity = -100; // Quick tap (even lower jump)
      const maxJumpVelocity = -400; // Max charge (even lower jump)
      const maxChargeTime = 600; // 600ms to reach max charge
      const chargeRatio = Math.min(holdDuration / maxChargeTime, 1);
      const jumpVelocity = minJumpVelocity + (maxJumpVelocity - minJumpVelocity) * chargeRatio;
      gameState.player.setVelocityY(jumpVelocity);
      gameState.jumpSound.play();
      gameState.coyoteTime = 0;
      gameState.jumpBufferTime = 0;
    }

    // Jump buffering - store jump input (only when space pressed in air)
    if (gameState.cursors.space.isDown && !onGroundOrShelter && !gameState.isJumping) {
      gameState.jumpBufferTime = 0.15; // 150ms buffer window
    }

    // Execute buffered jump when landing
    if (gameState.jumpBufferTime > 0 && onGroundOrShelter && !gameState.isJumping && !gameState.spaceHeld) {
      gameState.isJumping = true;
      gameState.hasLeftGround = false;
      gameState.jumpStartVelocityX = gameState.player.body.velocity.x;
      gameState.player.setVelocityY(-300);
      gameState.jumpBufferTime = 0;
    }

    // Jump animation sequence - runs every frame during jump
    if (gameState.isJumping) {
      if (!onGroundOrShelter) {
        // Player is in air
        gameState.hasLeftGround = true;
        const velocityY = gameState.player.body.velocity.y;

        // Variable jump height - cut jump short if space released early
        if (velocityY < 0 && !gameState.cursors.space.isDown) {
          gameState.player.setVelocityY(velocityY * 0.5); // Cut upward momentum
        }

        // Apply manual gravity when in air
        if (velocityY >= 0) {
          // Falling - stronger gravity for snappier feel
          gameState.player.setVelocityY(velocityY + 20); // Falling gravity per frame
        } else {
          // Rising - lighter gravity
          gameState.player.setVelocityY(velocityY + 12); // Rising gravity per frame
        }

        // Frame 2: Going up (negative velocity)
        if (velocityY < 0) {
          safeSetTexture(gameState.player, 'spritesheet', 2);
        }
        // Frame 3: Falling down (positive velocity)
        else {
          safeSetTexture(gameState.player, 'spritesheet', 3);
        }
      } else if (gameState.hasLeftGround || onGroundOrShelter) {
        // Just landed
        safeSetTexture(gameState.player, 'spritesheet', 0);
        gameState.isJumping = false;
        gameState.hasLeftGround = false;

        // Landing animation sequence
        gameState.scene.time.delayedCall(200, () => {
          if (!gameState.isClimbing && !gameState.isCrouching && !gameState.isJumping) {
            safeSetTexture(gameState.player, 'spritesheet', 5);
          }
        });

        gameState.scene.time.delayedCall(350, () => {
          if (!gameState.isClimbing && !gameState.isCrouching && !gameState.isJumping) {
            safeSetTexture(gameState.player, 'spritesheet', 0);
          }
        });
      }
    }

    // Update coyote time (grace period after leaving platform or standing on shelter)
    // (onGroundOrShelter already declared and set at top of update loop)
    if (onGroundOrShelter) {
      gameState.coyoteTime = 0.15; // 150ms grace period
    } else if (gameState.coyoteTime > 0) {
      gameState.coyoteTime -= deltaTime;
      if (gameState.coyoteTime < 0) gameState.coyoteTime = 0;
    }

    // Update jump buffer timer
    if (gameState.jumpBufferTime > 0) {
      gameState.jumpBufferTime -= deltaTime;
      if (gameState.jumpBufferTime < 0) gameState.jumpBufferTime = 0;
    }
  }

  // Climbing mechanics
  if (gameState.isClimbing) {
    gameState.player.setVelocityX(0); // Lock horizontal movement while climbing

    // Calculate max climb height (top of tree trunk zone)
    const maxClimbHeight = gameState.treeTrunk.y - (gameState.treeTrunk.height / 2 - 29);
    const atMaxHeight = gameState.player.y <= maxClimbHeight;

    // Calculate bottom third of tree (where player must stay centered)
    const treeBottom = gameState.treeTrunk.y + (gameState.treeTrunk.height / 2);
    const bottomThirdHeight = treeBottom - (gameState.treeTrunk.height / 3);
    const inBottomThird = gameState.player.y >= bottomThirdHeight;

        // Only allow side positioning in top 2/3 of tree
        // (sun/moon logic intentionally kept only in the sky section earlier)
        if (!inBottomThird) {
          if (timeSinceLastDamage >= holdInterval && branchHealth > 0) {
              branchHealth -= 1;
              closestBranch.setData('health', branchHealth);
              closestBranch.setData('lastDamageTime', currentTime);
            }
          }

          // Update frame based on current health
          if (branchHealth === 3) {
            try { closestBranch.setFrame(0); } catch (e) {}
          } else if (branchHealth === 2) {
            safeSetFrame(closestBranch, 0);
            safeSetFrame(closestBranch, 1);
            safeSetFrame(closestBranch, 2);
          }

          // If branch depleted, make it fall
          if (branchHealth === 0) {
            safeSetFrame(closestBranch, 0);
            closestBranch.body.setAllowGravity(true);
            closestBranch.body.setImmovable(false);
            closestBranch.body.setVelocityX(0);
            closestBranch.body.setVelocityY(50);
            closestBranch.setData('onTree', false);
            closestBranch.setData('beingCut', false);

            // Schedule regeneration after a delay. For fully-cut branches we spawn
            // a NEW branch at a random valid location (with midpoint fallback).
            const fallenBranch = closestBranch;
            gameState.scene.time.delayedCall(gameState.branchRegenerationDelay * 1000, () => {
              const attemptGrow = () => {
                const branchesOnTree = gameState.branches.getChildren().filter(b => b.active && b.getData('onTree')).length;
                const nowSec = Date.now() / 1000;
                const timeSinceLastGrow = nowSec - gameState.lastBranchGrowTime;

                if (branchesOnTree < gameState.maxBranches && timeSinceLastGrow >= gameState.branchGrowCooldown) {
                  const availableHeight = gameState.treeTrunk.height * (2 / 3);
                  const minSpacing = 50;
                  const branchMargin = 20;
                  const startY = gameState.treeTrunk.y - (gameState.treeTrunk.height / 2) + branchMargin;

                  const existingBranches = gameState.branches.getChildren().filter(b => b.active && b.getData('onTree'));
                  let validPosition = false;
                  let randomHeight;
                  let attempts = 0;
                  const maxAttempts = 20;

                  while (!validPosition && attempts < maxAttempts) {
                    randomHeight = startY + Math.random() * availableHeight;
                    validPosition = true;
                    for (const branch of existingBranches) {
                      if (Math.abs(branch.y - randomHeight) < minSpacing) {
                        validPosition = false;
                        break;
                      }
                    }
                    attempts++;
                  }

                  // If random sampling fails, use the midpoint as a fallback
                  if (!validPosition) {
                    randomHeight = startY + availableHeight * 0.5;
                    validPosition = true;
                  }

                  if (validPosition) {
                    // Create a brand-new growing branch. It starts partially-grown
                    // and will grow to full health over time. While `growing` is true
                    // the branch cannot be cut.
                    const newBranch = gameState.branches.create(gameState.treeTrunk.x, randomHeight, 'branch', 2).setScale(1.5).setDepth(300);
                    newBranch.body.setAllowGravity(false);
                    newBranch.body.setImmovable(true);

                    // Start partially grown: health=1 (frame 2). Mark as growing so it
                    // cannot be cut until fully grown.
                    newBranch.setData('health', 1);
                    newBranch.setData('growing', true);
                    newBranch.setData('onTree', true);

                    if (Math.random() > 0.5) {
                      newBranch.setFlipX(true);
                      newBranch.x += gameState.treeTrunk.width;
                    } else {
                      newBranch.x -= gameState.treeTrunk.width;
                    }

                    gameState.lastBranchGrowTime = nowSec;

                    // Growth routine: increase health by 1 every second until full
                    const growStep = () => {
                      if (!newBranch || !newBranch.active) return;
                      // If branch fell or was flagged not on tree, stop growing
                      if (!newBranch.getData('onTree')) {
                        newBranch.setData('growing', false);
                        newBranch.setData('growTimer', null);
                        return;
                      }
                      let h = newBranch.getData('health') || 0;
                      h = Math.min(3, h + 1);
                      newBranch.setData('health', h);
                      // Update frame for visual growth
                      try {
                        try {
                          if (h === 3) safeSetFrame(newBranch, 0);
                          else if (h === 2) safeSetFrame(newBranch, 1);
                          else if (h === 1) safeSetFrame(newBranch, 2);
                        } catch (e) {}
                      } catch (e) {}

                      if (h < 3) {
                        const t = gameState.scene.time.delayedCall(1000, growStep);
                        newBranch.setData('growTimer', t);
                      } else {
                        // Fully grown: allow cutting
                        newBranch.setData('growing', false);
                        newBranch.setData('growTimer', null);
                      }
                    };

                    // Start first growth tick after 1s
                    const t0 = gameState.scene.time.delayedCall(1000, growStep);
                    newBranch.setData('growTimer', t0);
                  }
                } else if (branchesOnTree < gameState.maxBranches) {
                  gameState.scene.time.delayedCall(1000, attemptGrow);
                }
              };
              attemptGrow();
            });
          }
        } else {
          // Player is holding space but not cutting any branch: mark branches
          // as not being cut (do not schedule/cancel heals here).
          gameState.branches.getChildren().forEach(branch => {
            branch.setData('beingCut', false);
          });
        }
        }
        
    // Reset spacebar flag when released (guard if `cursors` missing)
    if (!gameState.cursors || !gameState.cursors.space || !gameState.cursors.space.isDown) {
      if (gameState.spacePressed) {
        // Check if minimum chainsaw duration has passed
        const chainsawDuration = Date.now() - (gameState.chainsawStartTime || 0);

        if (chainsawDuration >= (gameState.chainsawMinDuration || 0)) {
          // Minimum duration met, can stop sound immediately
          gameState.sawAttack.stop();
          gameState.sawSustainLoop.stop();
          gameState.sawSoundPlaying = false;
        } else {
          // Keep sound playing until minimum duration is met
          const remainingTime = (gameState.chainsawMinDuration || 0) - chainsawDuration;
          gameState.scene.time.delayedCall(remainingTime, () => {
            gameState.sawAttack.stop();
            gameState.sawSustainLoop.stop();
            gameState.sawSoundPlaying = false;
          });
        }
      }
      // When the player releases space, mark branches as not being cut.
      // Do NOT cancel heal timers here â€” the gradual heal routine handles
      // scheduling and will continue healing even if the player remains nearby.
      const _branches = (gameState.branches && typeof gameState.branches.getChildren === 'function') ? gameState.branches.getChildren() : [];
      _branches.forEach(branch => {
        try { branch.setData('beingCut', false); } catch (e) {}
      });
      gameState.spacePressed = false;
    

    const curs = gameState.cursors;
    const p = gameState.player;
    const cs = gameState.climbingSound;
    // Compute climb limits locally to avoid scope/reference issues
    let maxClimbHeightLocal = null;
    let atMaxHeightLocal = false;
    if (p && gameState.treeTrunk) {
      maxClimbHeightLocal = gameState.treeTrunk.y - (gameState.treeTrunk.height / 2 - 29);
      atMaxHeightLocal = p.y <= maxClimbHeightLocal;
    }
    if (p && curs && curs.up && curs.up.isDown && !atMaxHeightLocal) {
      try { p.setVelocityY(-200); } catch (e) {}
      // Play climbing sound if not already playing
      try { if (cs && !cs.isPlaying) cs.play(); } catch (e) {}
    } else if (p && curs && curs.down && curs.down.isDown) {
      try { p.setVelocityY(200); } catch (e) {}
      // Play climbing sound if not already playing
      try { if (cs && !cs.isPlaying) cs.play(); } catch (e) {}
    } else {
      try { if (p) p.setVelocityY(0); } catch (e) {}
      // Stop climbing sound when not moving
      try { if (cs && cs.isPlaying) cs.stop(); } catch (e) {}
    }

    // Stop player at max height (use local computed values)
    if (atMaxHeightLocal && p && p.body && p.body.velocity && p.body.velocity.y < 0) {
      try { p.setVelocityY(0); if (maxClimbHeightLocal !== null) p.y = maxClimbHeightLocal; } catch (e) {}
    }
  }
  // Note: Removed manual gravity application here - Phaser's built-in gravity handles falling

  // Horizontal movement (allow when not climbing OR when on floor)
  // During jump: allow air control but at reduced speed
  if (!gameState.isClimbing && !gameState.buildMode && !gameState.buildMenuOpen) {
    if (gameState.isJumping && gameState.player && gameState.player.body && !gameState.player.body.onFloor()) {
      // Air control during jump - can only adjust in same direction or slow down
      const currentVelocityX = gameState.player.body.velocity.x;

      if (gameState.cursors.left.isDown) {
        if (currentVelocityX < 0) {
          // Moving left, can speed up slightly
          const targetVelocity = Math.max(gameState.jumpStartVelocityX, -200);
          if (currentVelocityX > targetVelocity) {
            gameState.player.setVelocityX(Math.max(currentVelocityX - 20, targetVelocity));
          }
        } else if (currentVelocityX > 0) {
          // Moving right, can only slow down (not reverse)
          gameState.player.setVelocityX(Math.max(currentVelocityX - 5, 0));
        } else {
          // Standing still (velocity is 0), can start moving left
          gameState.player.setVelocityX(Math.max(currentVelocityX - 50, -200));
        }
        gameState.player.setFlipX(true);
      } else if (gameState.cursors.right.isDown) {
        if (currentVelocityX > 0) {
          // Moving right, can speed up slightly
          const targetVelocity = Math.min(gameState.jumpStartVelocityX, 200);
          if (currentVelocityX < targetVelocity) {
            gameState.player.setVelocityX(Math.min(currentVelocityX + 20, targetVelocity));
          }
        } else if (currentVelocityX < 0) {
          // Moving left, can only slow down (not reverse)
          gameState.player.setVelocityX(Math.min(currentVelocityX + 5, 0));
        } else {
          // Standing still (velocity is 0), can start moving right
          gameState.player.setVelocityX(Math.min(currentVelocityX + 50, 200));
        }
        gameState.player.setFlipX(false);
      }
      // Else preserve the velocity from jump start
    } else if (gameState.player && gameState.player.body && !gameState.player.body.onFloor()) {
      // Falling (not jumping, not on floor) - allow full air control
      const currentVelocityX = gameState.player.body.velocity.x;
      const airAcceleration = 30;
      const maxSpeed = 200;

      if (gameState.cursors.left.isDown) {
        const newVelocity = Math.max(currentVelocityX - airAcceleration, -maxSpeed);
        gameState.player.setVelocityX(newVelocity);
        gameState.player.setFlipX(true);
      } else if (gameState.cursors.right.isDown) {
        const newVelocity = Math.min(currentVelocityX + airAcceleration, maxSpeed);
        gameState.player.setVelocityX(newVelocity);
        gameState.player.setFlipX(false);
      }
    } else if (gameState.player && gameState.player.body && gameState.player.body.onFloor()) {
      // Full control on ground with acceleration/deceleration
      const currentVelocityX = gameState.player.body.velocity.x;
      const acceleration = 50; // Speed up gradually (increased from 30)
      const deceleration = 40; // Slow down gradually (increased from 20)
      const maxSpeed = 200;

      if (gameState.cursors.left.isDown && gameState.cursors.right.isDown) {
        // Both keys pressed - move at half speed in the direction of the first key pressed
        if (gameState.cursors.left.timeDown < gameState.cursors.right.timeDown) {
          gameState.player.setVelocityX(-100);
          gameState.player.setFlipX(true);
        } else {
          gameState.player.setVelocityX(100);
          gameState.player.setFlipX(false);
        }
      } else if (gameState.cursors.left.isDown) {
        // Accelerate left
        const newVelocity = Math.max(currentVelocityX - acceleration, -maxSpeed);
        gameState.player.setVelocityX(newVelocity);
        gameState.player.setFlipX(true);
      } else if (gameState.cursors.right.isDown) {
        // Accelerate right
        const newVelocity = Math.min(currentVelocityX + acceleration, maxSpeed);
        gameState.player.setVelocityX(newVelocity);
        gameState.player.setFlipX(false);
      } else {
        // Decelerate to stop
        if (Math.abs(currentVelocityX) > deceleration) {
          gameState.player.setVelocityX(currentVelocityX - Math.sign(currentVelocityX) * deceleration);
        } else {
          gameState.player.setVelocityX(0);
        }
      }
    }
  }


const config = {
  type: Phaser.AUTO,
  width: w,
  height: h,
  backgroundColor: "b9eaff",
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 600 },
      enableBody: true,
      debug: true
    }
  },
  scene: {
    preload,
    create,
    update
  },
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: w,
    height: h
  }
};

const game = new Phaser.Game(config);
